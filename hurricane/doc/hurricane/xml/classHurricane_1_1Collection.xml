<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="classHurricane_1_1Collection" kind="class" language="C++" prot="public" abstract="yes">
    <compoundname>Hurricane::Collection</compoundname>
    <derivedcompoundref refid="classHurricane_1_1Component_1_1Points__Contour" prot="public" virt="non-virtual">Hurricane::Component::Points_Contour</derivedcompoundref>
    <derivedcompoundref refid="classHurricane_1_1ElementCollection" prot="public" virt="non-virtual">Hurricane::ElementCollection&lt; Type &gt;</derivedcompoundref>
    <derivedcompoundref refid="classHurricane_1_1GenericCollection" prot="public" virt="non-virtual">Hurricane::GenericCollection&lt; Type &gt;</derivedcompoundref>
    <derivedcompoundref refid="classHurricane_1_1Polygon_1_1Points__Manhattan" prot="public" virt="non-virtual">Hurricane::Polygon::Points_Manhattan</derivedcompoundref>
    <derivedcompoundref refid="classHurricane_1_1SubSetCollection" prot="public" virt="non-virtual">Hurricane::SubSetCollection&lt; Type &gt;</derivedcompoundref>
    <innerclass refid="classHurricane_1_1Collection_1_1iterator" prot="public">Hurricane::Collection::iterator</innerclass>
    <templateparamlist>
      <param>
        <type>class Type</type>
      </param>
    </templateparamlist>
      <sectiondef kind="protected-func">
      <memberdef kind="function" id="classHurricane_1_1Collection_1af4549158ab8875f8f96690ca4dfb42a0" prot="protected" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>Hurricane::Collection&lt; Type &gt;::Collection</definition>
        <argsstring>()</argsstring>
        <name>Collection</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" line="45" column="16" bodyfile="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" bodystart="45" bodyend="48"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="classHurricane_1_1Collection_1a3742402abd0603cd508bb218b0a1129d" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>Hurricane::Collection&lt; Type &gt;::Collection</definition>
        <argsstring>(const Collection &amp;collection)</argsstring>
        <name>Collection</name>
        <param>
          <type>const <ref refid="classHurricane_1_1Collection" kindref="compound">Collection</ref> &amp;</type>
          <declname>collection</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" line="50" column="14"/>
      </memberdef>
      <memberdef kind="function" id="classHurricane_1_1Collection_1acf3eb413942b1edeb73550ce13c661fa" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classHurricane_1_1Collection" kindref="compound">Collection</ref> &amp;</type>
        <definition>Collection&amp; Hurricane::Collection&lt; Type &gt;::operator=</definition>
        <argsstring>(const Collection &amp;collection)</argsstring>
        <name>operator=</name>
        <param>
          <type>const <ref refid="classHurricane_1_1Collection" kindref="compound">Collection</ref> &amp;</type>
          <declname>collection</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" line="66" column="25"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classHurricane_1_1Collection_1aafcf8e05658e245b2a762baa7a59f281" prot="public" static="no" const="no" explicit="no" inline="yes" virt="virtual">
        <type></type>
        <definition>Hurricane::Collection&lt; Type &gt;::~Collection&lt; Type &gt;</definition>
        <argsstring>()</argsstring>
        <name>~Collection</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Destroys the collection but doesn&apos;t acts on elements refered by this collection. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" line="58" column="21" bodyfile="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" bodystart="58" bodyend="61"/>
      </memberdef>
      <memberdef kind="function" id="classHurricane_1_1Collection_1ac75b91d3952b36e14f21174958523924" prot="public" static="no" const="yes" explicit="no" inline="no" virt="pure-virtual">
        <type><ref refid="classHurricane_1_1Collection" kindref="compound">Collection</ref>&lt; Type &gt; *</type>
        <definition>Collection&lt; Type &gt; * Hurricane::Collection&lt; Type &gt;::getClone</definition>
        <argsstring>() const =0</argsstring>
        <name>getClone</name>
        <reimplementedby refid="classHurricane_1_1GenericCollection_1a410aaabacb775eee53d4a597b3e77d2f">getClone</reimplementedby>
        <reimplementedby refid="classHurricane_1_1GenericCollection_1a410aaabacb775eee53d4a597b3e77d2f">getClone</reimplementedby>
        <reimplementedby refid="classHurricane_1_1SubTypeCollection_1ab4d225ecd8fbd41e2c531894f1b01de1">getClone</reimplementedby>
        <reimplementedby refid="classHurricane_1_1SubSetCollection_1a9a681a9382303671a85272fcee2fc9e3">getClone</reimplementedby>
        <reimplementedby refid="classHurricane_1_1ListCollection_1a83ff16550d97edf0374dd8dbde882f06">getClone</reimplementedby>
        <reimplementedby refid="classHurricane_1_1MapCollection_1a3dfabd0740f06a2a105c691c0e597257">getClone</reimplementedby>
        <reimplementedby refid="classHurricane_1_1SetCollection_1a348461adf89f1188c1d471c1912134be">getClone</reimplementedby>
        <reimplementedby refid="classHurricane_1_1VectorCollection_1aa2fbaf62db5790416d5b74727b951012">getClone</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Allocates and returns a clone (copy) of the collection (whatever be its type).</para>
<para><simplesect kind="remark"><para>In principle there is no need to use this function. However, if you do so, don&apos;t forget to delete the clone after use. It is indeed much easier to use generic collections which do that for you, as we will see later. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" line="74" column="32"/>
      </memberdef>
      <memberdef kind="function" id="classHurricane_1_1Collection_1a48fd1a0a2b6d2530a87e22ba65aa3152" prot="public" static="no" const="yes" explicit="no" inline="no" virt="pure-virtual">
        <type><ref refid="classHurricane_1_1Locator" kindref="compound">Locator</ref>&lt; Type &gt; *</type>
        <definition>Locator&lt; Type &gt; * Hurricane::Collection&lt; Type &gt;::getLocator</definition>
        <argsstring>() const =0</argsstring>
        <name>getLocator</name>
        <reimplementedby refid="classHurricane_1_1GenericCollection_1acaabf6a2b0459b31cc3858d70b6c40ca">getLocator</reimplementedby>
        <reimplementedby refid="classHurricane_1_1GenericCollection_1acaabf6a2b0459b31cc3858d70b6c40ca">getLocator</reimplementedby>
        <reimplementedby refid="classHurricane_1_1SubTypeCollection_1a4a2a582a971b3d875a56d30cf778b9e3">getLocator</reimplementedby>
        <reimplementedby refid="classHurricane_1_1SubSetCollection_1a0472077aa51108254e58841f64be4663">getLocator</reimplementedby>
        <reimplementedby refid="classHurricane_1_1ListCollection_1a3e1018142ce414d71f18dab9b986685e">getLocator</reimplementedby>
        <reimplementedby refid="classHurricane_1_1MapCollection_1a69adc3c0ecaf6ee1eed2d973c6e158fe">getLocator</reimplementedby>
        <reimplementedby refid="classHurricane_1_1SetCollection_1a099a3a0c4246038cd5bd2b50bed56760">getLocator</reimplementedby>
        <reimplementedby refid="classHurricane_1_1VectorCollection_1a9f135aa7994f45fc92bb44b0d91151dd">getLocator</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Allocates and returns a locator adapted to visit the elements of the collection.</para>
<para><simplesect kind="remark"><para>In principle there is no need to use this function. Use preferably the macro <bold>for_each</bold> described below. However, if you do so, don&apos;t forget to delete this locator after use, else use generic locators, which do that for you, as we will see later. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" line="76" column="29"/>
        <referencedby refid="classHurricane_1_1Collection_1a846a042646e02a0f77d2ce0f6190288a" compoundref="Collection_8h" startline="91" endline="96">Hurricane::Collection&lt; Type &gt;::getFirst</referencedby>
        <referencedby refid="classHurricane_1_1Collection_1a1292aabe88c9aadfdfe21dabddb62c19" compoundref="Collection_8h" startline="78" endline="89">Hurricane::Collection&lt; Type &gt;::getSize</referencedby>
      </memberdef>
      <memberdef kind="function" id="classHurricane_1_1Collection_1a1292aabe88c9aadfdfe21dabddb62c19" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="virtual">
        <type>unsigned</type>
        <definition>unsigned Hurricane::Collection&lt; Type &gt;::getSize</definition>
        <argsstring>() const</argsstring>
        <name>getSize</name>
        <reimplementedby refid="classHurricane_1_1GenericCollection_1a5451903d7945b5aa7085556218518464">getSize</reimplementedby>
        <reimplementedby refid="classHurricane_1_1GenericCollection_1a5451903d7945b5aa7085556218518464">getSize</reimplementedby>
        <reimplementedby refid="classHurricane_1_1ListCollection_1a1a4ee037a9f63388bee3865d99df55aa">getSize</reimplementedby>
        <reimplementedby refid="classHurricane_1_1MapCollection_1aec528d7a40fd477f526d488affc227c9">getSize</reimplementedby>
        <reimplementedby refid="classHurricane_1_1SetCollection_1ade6d631d76590264c8cdc0fa99712125">getSize</reimplementedby>
        <reimplementedby refid="classHurricane_1_1VectorCollection_1a104fc7e1c0d220d8e0c995f10c019606">getSize</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><bold>Returns:</bold> the number of objects identified within the collection.</para>
<para><simplesect kind="remark"><para>Very fast in some cases, but may need to visit the collection in most ones. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" line="78" column="30" bodyfile="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" bodystart="78" bodyend="89"/>
        <references refid="classHurricane_1_1Collection_1a48fd1a0a2b6d2530a87e22ba65aa3152">Hurricane::Collection&lt; Type &gt;::getLocator</references>
      </memberdef>
      <memberdef kind="function" id="classHurricane_1_1Collection_1a846a042646e02a0f77d2ce0f6190288a" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>Type</type>
        <definition>Type Hurricane::Collection&lt; Type &gt;::getFirst</definition>
        <argsstring>() const</argsstring>
        <name>getFirst</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><bold>Returns:</bold> the first element of the collection.</para>
<para><simplesect kind="remark"><para>The result is meaningful only when the collection is non empty. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" line="91" column="18" bodyfile="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" bodystart="91" bodyend="96"/>
        <references refid="classHurricane_1_1Collection_1a48fd1a0a2b6d2530a87e22ba65aa3152">Hurricane::Collection&lt; Type &gt;::getLocator</references>
      </memberdef>
      <memberdef kind="function" id="classHurricane_1_1Collection_1aa32ea7249d57ee05e3c71dcde8106832" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classHurricane_1_1GenericCollection" kindref="compound">GenericCollection</ref>&lt; Type &gt;</type>
        <definition>GenericCollection&lt; Type &gt; Hurricane::Collection&lt; Type &gt;::getSubSet</definition>
        <argsstring>(const Filter&lt; Type &gt; &amp;filter) const</argsstring>
        <name>getSubSet</name>
        <param>
          <type>const <ref refid="classHurricane_1_1Filter" kindref="compound">Filter</ref>&lt; Type &gt; &amp;</type>
          <declname>filter</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><bold>Returns:</bold> the collection representing the subset of elements accepted by the filter. <programlisting><codeline><highlight class="normal">Nets<sp/>Cell::getExternalNets()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>return<sp/>getNets().getSubSet(Net::getIsExternalFilter());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" line="98" column="31" bodyfile="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" bodystart="98" bodyend="102"/>
      </memberdef>
      <memberdef kind="function" id="classHurricane_1_1Collection_1a91d986e21395d4021d927e06f204ab6c" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class SubType</type>
          </param>
        </templateparamlist>
        <type><ref refid="classHurricane_1_1GenericCollection" kindref="compound">GenericCollection</ref>&lt; SubType &gt;</type>
        <definition>GenericCollection&lt; SubType &gt; Hurricane::Collection&lt; Type &gt;::getSubSet&lt; SubType &gt;</definition>
        <argsstring>() const</argsstring>
        <name>getSubSet</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><bold>Returns:</bold> the collection corresponding to the subset of elements of type <computeroutput>&lt;SubType&gt;</computeroutput>.</para>
<para><simplesect kind="remark"><para>The returned collection is a collection of objects of type <bold>SubType</bold> and not of type <bold>Type</bold>.</para>
</simplesect>
<programlisting><codeline><highlight class="normal">Contacts<sp/>Net::getContacts()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>return<sp/>getComponents().getSubSet&lt;Contact*&gt;();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" line="104" column="42" bodyfile="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" bodystart="104" bodyend="108"/>
      </memberdef>
      <memberdef kind="function" id="classHurricane_1_1Collection_1a673afd14782da82ad03a68366ae1f09b" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class SubType</type>
          </param>
        </templateparamlist>
        <type><ref refid="classHurricane_1_1GenericCollection" kindref="compound">GenericCollection</ref>&lt; SubType &gt;</type>
        <definition>GenericCollection&lt; SubType &gt; Hurricane::Collection&lt; Type &gt;::getSubSet&lt; SubType &gt;</definition>
        <argsstring>(const Filter&lt; SubType &gt; &amp;filter) const</argsstring>
        <name>getSubSet</name>
        <param>
          <type>const <ref refid="classHurricane_1_1Filter" kindref="compound">Filter</ref>&lt; SubType &gt; &amp;</type>
          <declname>filter</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><bold>Returns:</bold> the collection representing the subset of elements of type <computeroutput>&lt;SubType&gt;</computeroutput> accepted by the filter.</para>
<para><simplesect kind="remark"><para>The returned collection is a collection of elements of type <bold>SubType</bold> and not of type <bold>Type</bold> and the filter must be a filter of elements of type <bold>SubType</bold>.</para>
</simplesect>
<simplesect kind="par"><title>Sample:\n Filter Hurricane::Segment according to their Layer.</title><para><programlisting><codeline><highlight class="normal">class<sp/>IsOnLayer<sp/>:<sp/>public<sp/>Filter&lt;Segment*&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Layer*<sp/>_layer;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>IsOnLayer(Layer*<sp/>layer)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>_layer(layer)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!_layer)<sp/>throw<sp/>Error(&quot;Can&apos;t<sp/>create<sp/>IsOnLayer<sp/>filter<sp/>:<sp/>null<sp/>layer&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>IsOnLayer(const<sp/>IsOnLayer&amp;<sp/>isOnLayer)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>_layer(isOnLayer._layer)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>{<sp/>};</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>IsOnLayer&amp;<sp/>operator=(const<sp/>IsOnLayer&amp;<sp/>isOnLayer)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_layer<sp/>=<sp/>isOnLayer._layer;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>*this;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>virtual<sp/>Filter&lt;Net*&gt;*<sp/>getClone()<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>new<sp/>IsOnLayer(*this);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>virtual<sp/>bool<sp/>Accept(Segment*<sp/>segment)<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>(segmentgetLayer()<sp/>==<sp/>_layer);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
</simplesect>
And somewher later: <programlisting><codeline><highlight class="normal">Layer*<sp/>metal<sp/>=<sp/>getDataBase()-&gt;getTechnology()-&gt;getLayer(&quot;metal&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal">Segments<sp/>segments<sp/>=<sp/>net-&gt;getComponents()-&gt;getSubSet&lt;Segment*&gt;(IsOnLayer(metal));</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal">//<sp/>segments<sp/>represents<sp/>here<sp/>the<sp/>subset<sp/>of<sp/>net<sp/>components</highlight></codeline>
<codeline><highlight class="normal">//<sp/>which<sp/>are<sp/>of<sp/>type<sp/>Segment<sp/>and<sp/>located<sp/>on<sp/>layer<sp/>metal</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" line="111" column="33" bodyfile="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" bodystart="111" bodyend="115"/>
      </memberdef>
      <memberdef kind="function" id="classHurricane_1_1Collection_1a9076419d7ee2359d16a46e4e6366a832" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class SubType</type>
          </param>
        </templateparamlist>
        <type><ref refid="classHurricane_1_1GenericCollection" kindref="compound">GenericCollection</ref>&lt; SubType &gt;</type>
        <definition>GenericCollection&lt;SubType&gt; Hurricane::Collection&lt; Type &gt;::getNotSubSet</definition>
        <argsstring>() const</argsstring>
        <name>getNotSubSet</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" line="117" column="42" bodyfile="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" bodystart="117" bodyend="121"/>
      </memberdef>
      <memberdef kind="function" id="classHurricane_1_1Collection_1a83b09bcd4c26dd4f3977c59c547da428" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool Hurricane::Collection&lt; Type &gt;::isEmpty</definition>
        <argsstring>() const</argsstring>
        <name>isEmpty</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" line="126" column="18" bodyfile="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" bodystart="126" bodyend="131"/>
      </memberdef>
      <memberdef kind="function" id="classHurricane_1_1Collection_1aeb2e8875b60cb6aad62f2c9640f1fa23" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void Hurricane::Collection&lt; Type &gt;::fill</definition>
        <argsstring>(list&lt; Type &gt; &amp;list) const</argsstring>
        <name>fill</name>
        <param>
          <type>list&lt; Type &gt; &amp;</type>
          <declname>list</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" line="136" column="18" bodyfile="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" bodystart="136" bodyend="144"/>
      </memberdef>
      <memberdef kind="function" id="classHurricane_1_1Collection_1a087a86e240e7695c8a00e8975cf4385a" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void Hurricane::Collection&lt; Type &gt;::fill</definition>
        <argsstring>(set&lt; Type &gt; &amp;set) const</argsstring>
        <name>fill</name>
        <param>
          <type>set&lt; Type &gt; &amp;</type>
          <declname>set</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" line="146" column="18" bodyfile="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" bodystart="146" bodyend="154"/>
      </memberdef>
      <memberdef kind="function" id="classHurricane_1_1Collection_1abaa7dac9adab0cb6025059cfd495e221" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Compare</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void Hurricane::Collection&lt; Type &gt;::fill</definition>
        <argsstring>(set&lt; Type, Compare &gt; &amp;set) const</argsstring>
        <name>fill</name>
        <param>
          <type>set&lt; Type, Compare &gt; &amp;</type>
          <declname>set</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" line="156" column="29" bodyfile="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" bodystart="156" bodyend="164"/>
      </memberdef>
      <memberdef kind="function" id="classHurricane_1_1Collection_1a24420b64124ffee31c1cc296b33f015c" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void Hurricane::Collection&lt; Type &gt;::fill</definition>
        <argsstring>(vector&lt; Type &gt; &amp;vector) const</argsstring>
        <name>fill</name>
        <param>
          <type>vector&lt; Type &gt; &amp;</type>
          <declname>vector</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" line="166" column="18" bodyfile="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" bodystart="166" bodyend="174"/>
      </memberdef>
      <memberdef kind="function" id="classHurricane_1_1Collection_1a932ce759bea5022ef302a679aa08ea90" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="virtual">
        <type>string</type>
        <definition>virtual string Hurricane::Collection&lt; Type &gt;::_getTypeName</definition>
        <argsstring>() const</argsstring>
        <name>_getTypeName</name>
        <reimplementedby refid="classHurricane_1_1GenericCollection_1ac73c5f68731f2aabc188a2db03b2d3be">_getTypeName</reimplementedby>
        <reimplementedby refid="classHurricane_1_1GenericCollection_1ac73c5f68731f2aabc188a2db03b2d3be">_getTypeName</reimplementedby>
        <reimplementedby refid="classHurricane_1_1ListCollection_1ac5488b53830e09bb40af7023dc281783">_getTypeName</reimplementedby>
        <reimplementedby refid="classHurricane_1_1MapCollection_1ac1cf73a6ab10a86f0729ce86ef8e9573">_getTypeName</reimplementedby>
        <reimplementedby refid="classHurricane_1_1SetCollection_1a9b344977adb13fe1f42f90af1dede1a2">_getTypeName</reimplementedby>
        <reimplementedby refid="classHurricane_1_1VectorCollection_1ab63c4d747b4e2d587d5f8692b11d2ea7">_getTypeName</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" line="179" column="28" bodyfile="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" bodystart="179" bodyend="183"/>
      </memberdef>
      <memberdef kind="function" id="classHurricane_1_1Collection_1abfb8b31dadc9cf977df24ef844ca64ab" prot="public" static="no" const="yes" explicit="no" inline="no" virt="pure-virtual">
        <type>string</type>
        <definition>virtual string Hurricane::Collection&lt; Type &gt;::_getString</definition>
        <argsstring>() const =0</argsstring>
        <name>_getString</name>
        <reimplementedby refid="classHurricane_1_1GenericCollection_1a2bf0f744c9343207738751de30a36a06">_getString</reimplementedby>
        <reimplementedby refid="classHurricane_1_1GenericCollection_1a2bf0f744c9343207738751de30a36a06">_getString</reimplementedby>
        <reimplementedby refid="classHurricane_1_1SubTypeCollection_1ae06daf4716751aafcd7d98713694c1e2">_getString</reimplementedby>
        <reimplementedby refid="classHurricane_1_1SubSetCollection_1ab2d9cff40279ccf9830d1a77589badd0">_getString</reimplementedby>
        <reimplementedby refid="classHurricane_1_1ListCollection_1a4f71ec6eb291cc6e52dc68718e48610e">_getString</reimplementedby>
        <reimplementedby refid="classHurricane_1_1MapCollection_1afc9cf01a1a8b4042aede795215ba07be">_getString</reimplementedby>
        <reimplementedby refid="classHurricane_1_1SetCollection_1aeabebbf933d563093b290e3801a19024">_getString</reimplementedby>
        <reimplementedby refid="classHurricane_1_1VectorCollection_1af6ddd16a3aa01fed808cc094f2f346a9">_getString</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" line="185" column="28"/>
      </memberdef>
      <memberdef kind="function" id="classHurricane_1_1Collection_1a16575a202d17448f989df8dffd242ebf" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>Record *</type>
        <definition>Record* Hurricane::Collection&lt; Type &gt;::_getRecord</definition>
        <argsstring>() const</argsstring>
        <name>_getRecord</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" line="187" column="20" bodyfile="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" bodystart="187" bodyend="203"/>
      </memberdef>
      <memberdef kind="function" id="classHurricane_1_1Collection_1ab68531402b19649f02a6c2b0021354ec" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>iterator</type>
        <definition>iterator Hurricane::Collection&lt; Type &gt;::begin</definition>
        <argsstring>()</argsstring>
        <name>begin</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" line="224" column="14" bodyfile="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" bodystart="224" bodyend="224"/>
      </memberdef>
      <memberdef kind="function" id="classHurricane_1_1Collection_1abb40704519d3ff36ed1698dc648704ad" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>iterator</type>
        <definition>iterator Hurricane::Collection&lt; Type &gt;::end</definition>
        <argsstring>()</argsstring>
        <name>end</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" line="225" column="14" bodyfile="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" bodystart="225" bodyend="225"/>
      </memberdef>
      <memberdef kind="function" id="classHurricane_1_1Collection_1ae98948c714b5664e6fb3455a61c9ed3b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool Hurricane::Collection&lt; Type &gt;::empty</definition>
        <argsstring>()</argsstring>
        <name>empty</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" line="226" column="14" bodyfile="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" bodystart="226" bodyend="226"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para><ref refid="classHurricane_1_1Collection" kindref="compound">Collection</ref> description (<bold>API</bold>) </para>
    </briefdescription>
    <detaileddescription>
<sect1 id="classHurricane_1_1Collection_1secCollectionIntro">
<title>Introduction</title>
<para>Collections introduce the concept of set of elements.</para>
<para>Strictly speaking collections are not containers (in the STL way) but indeed set descriptors. For example, the set of instances called by a cell, which are located within a given rectangular area, will be a subtype of <ref refid="classHurricane_1_1Collection" kindref="compound">Collection</ref>&lt;Instance*&gt; whose first attribute will be a pointer to the cell and a second attribute the rectangular area.</para>
<para>Main characteristics of Collections: <itemizedlist>
<listitem>
<para>Collections <bold>do not own</bold> their elements (they remains when the <ref refid="classHurricane_1_1Collection" kindref="compound">Collection</ref> is deleted). </para>
</listitem>
<listitem>
<para>They can only be iterated <emphasis>forward</emphasis>. Once an element is consumed you cannot go back to it. You must restart the collection walktrough instead. </para>
</listitem>
<listitem>
<para>Collections are very light objects which are built, copied or destroyed very rapidly. </para>
</listitem>
</itemizedlist>
</para>
</sect1>
<sect1 id="classHurricane_1_1Collection_1secIterator">
<title>STL Iterator Support</title>
<para>The Collections now provides a basic iterator support to allow the C++11 <computeroutput>for</computeroutput> contruct: <programlisting><codeline><highlight class="normal">Cell*<sp/>cell<sp/>=<sp/>...;<sp/>//<sp/>Get<sp/>a<sp/>Cell<sp/>from<sp/>somewhere.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">for(<sp/>Net*<sp/>inet<sp/>:<sp/>cell-&gt;getNets()<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cout<sp/>&lt;&lt;<sp/>&quot;This<sp/>is<sp/>&quot;<sp/>&lt;&lt;<sp/>inet;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(inet-&gt;isExternal())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>&quot;<sp/>[external<sp/>net].&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cout<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> Although the <computeroutput>forEach</computeroutput> macro is still retained for backward compatibility, it is advisable to use the C++11 way.</para>
</sect1>
<sect1 id="classHurricane_1_1Collection_1secForEachMacro">
<title>The forEach Macro (obsoleted)</title>
<para>Collections are to be used in conjunction with the <computeroutput>forEach</computeroutput> macro which allows to easily iterate over the elements. Iteration is done through a simplistic iterator which have overload for the <computeroutput>operator*()</computeroutput> and <computeroutput>operator-&gt;()</computeroutput></para>
<para>The <computeroutput>forEach</computeroutput> macro takes three arguments: <center> <table rows="4" cols="2"><row>
<entry thead="yes" colspan="2"><para><computeroutput>forEach(type,iterator,collection)</computeroutput> </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>type</computeroutput> </para>
</entry><entry thead="no"><para>Element&apos;s type of the collection. </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>iterator</computeroutput> </para>
</entry><entry thead="no"><para><ref refid="classHurricane_1_1Name" kindref="compound">Name</ref> of the iterator&apos;s variable. </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>collection</computeroutput> </para>
</entry><entry thead="no"><para>An appropriate collection to iterate over, that is, built over <computeroutput>type</computeroutput> elements. </para>
</entry></row>
</table>
</center></para>
<para>To use the forEach macro outside the <ref refid="namespaceHurricane" kindref="compound">Hurricane</ref> namespace, the following statement is necessary: <programlisting><codeline><highlight class="normal">using<sp/>Hurricane::ForEachIterator</highlight></codeline>
</programlisting> Here is a small example of a loop: <programlisting><codeline><highlight class="normal">using<sp/>Hurricane::ForEachIterator;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Cell*<sp/>cell<sp/>=<sp/>...;<sp/>//<sp/>Get<sp/>a<sp/>Cell<sp/>from<sp/>somewhere.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">forEach(<sp/>Net*,<sp/>inet,<sp/>cell-&gt;getNets()<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cout<sp/>&lt;&lt;<sp/>&quot;This<sp/>is<sp/>&quot;<sp/>&lt;&lt;<sp/>(*inet);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(inet-&gt;isExternal())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>&quot;<sp/>[external<sp/>net].&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cout<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect1>
<sect1 id="classHurricane_1_1Collection_1secGenericgetCollection">
<title>The Generic getCollection</title>
<para>The collections provide the generic <computeroutput>getCollection()</computeroutput> function which allows to convert its argument into a generic collection. It has no specific interest for <ref refid="namespaceHurricane" kindref="compound">Hurricane</ref> collections, but this function is overloaded for STL containers.</para>
<para>This allows to handle a STL containers like a normal collection as shown in the following example: <programlisting><codeline><highlight class="normal">set&lt;Instance*&gt;<sp/>instanceSet;</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal">//<sp/>here<sp/>we<sp/>fill<sp/>the<sp/>set<sp/>with<sp/>the<sp/>desired<sp/>instances...<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal">forEach(Instance*,<sp/>iinstance,<sp/>getCollection(instanceSet))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>//<sp/>process<sp/>here<sp/>each<sp/>instance<sp/>of<sp/>the<sp/>set</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>//<sp/>(the<sp/>elements<sp/>are<sp/>visited<sp/>according<sp/>to<sp/>the<sp/>set<sp/>ordering)</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para><simplesect kind="remark"><para>This approach is a little bit less efficient than the use of STL iterators, not much indeed, but has the advantage to be homogeneous with the remaining code (recall: the created collection doesn&apos;t make a copy of the STL container and its creation time is negligible).</para>
</simplesect>
<simplesect kind="par"><title>Caution: The returned collection is valid whenever the STL container </title><para>is valid. Then you should not do the following: <programlisting><codeline><highlight class="normal">GenericCollection&lt;Instance*&gt;<sp/>getInstances(...)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>set&lt;Instance*&gt;<sp/>instanceSet;</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>//<sp/>we<sp/>fill<sp/>the<sp/>container<sp/>with<sp/>the<sp/>appropriate<sp/>instances</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>return<sp/>getCollection(instanceSet);<sp/>//<sp/>instanceSet<sp/>deleted<sp/>after<sp/>return</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</simplesect>
The same will occur anyway if you do: <programlisting><codeline><highlight class="normal">Cell*<sp/>cell<sp/>=<sp/>...;<sp/>//<sp/>we<sp/>get<sp/>the<sp/>cell</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal">Nets<sp/>nets<sp/>=<sp/>cell-&gt;getNets();</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal">cell-&gt;destroy();</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal">forEach(Net*,<sp/>inet,<sp/>nets)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect1>
<sect1 id="classHurricane_1_1Collection_1secCollectionLocators">
<title>Locators</title>
<para>Each type of collection provides an associated <ref refid="classHurricane_1_1Locator" kindref="compound">Locator</ref> for tracing through the corresponding set of elements.</para>
<para>Each locator moves efficiently through the data structure without building (in the form of a list or any other container type) the set of elements defined by the collection (it may however use a stack (or something else) to manage recursive traces).</para>
<para>The elements are therefore visited in the order with which they are internally stored. No assumptions must be made about this ordering. However, collections representing an STL container are visited in the same order than the container&apos;s one.</para>
<para>If you need to visit the objects in a given order, you must first fill a STL container: either a vector to be sorted accordingly or a set with the given sort criteria (see the Fill method below). </para>
</sect1>
    </detaileddescription>
    <inheritancegraph>
      <node id="2">
        <label>Hurricane::GenericCollection&lt; Type &gt;</label>
        <link refid="classHurricane_1_1GenericCollection"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1">
        <label>Hurricane::Collection&lt; Type &gt;</label>
        <link refid="classHurricane_1_1Collection"/>
      </node>
      <node id="3">
        <label>Hurricane::SubSetCollection&lt; Type &gt;</label>
        <link refid="classHurricane_1_1SubSetCollection"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <location file="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" line="39" column="11" bodyfile="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/src/hurricane/hurricane/Collection.h" bodystart="39" bodyend="227"/>
    <listofallmembers>
      <member refid="classHurricane_1_1Collection_1a16575a202d17448f989df8dffd242ebf" prot="public" virt="non-virtual"><scope>Hurricane::Collection</scope><name>_getRecord</name></member>
      <member refid="classHurricane_1_1Collection_1abfb8b31dadc9cf977df24ef844ca64ab" prot="public" virt="pure-virtual"><scope>Hurricane::Collection</scope><name>_getString</name></member>
      <member refid="classHurricane_1_1Collection_1a932ce759bea5022ef302a679aa08ea90" prot="public" virt="virtual"><scope>Hurricane::Collection</scope><name>_getTypeName</name></member>
      <member refid="classHurricane_1_1Collection_1ab68531402b19649f02a6c2b0021354ec" prot="public" virt="non-virtual"><scope>Hurricane::Collection</scope><name>begin</name></member>
      <member refid="classHurricane_1_1Collection_1af4549158ab8875f8f96690ca4dfb42a0" prot="protected" virt="non-virtual"><scope>Hurricane::Collection</scope><name>Collection</name></member>
      <member refid="classHurricane_1_1Collection_1a3742402abd0603cd508bb218b0a1129d" prot="private" virt="non-virtual"><scope>Hurricane::Collection</scope><name>Collection</name></member>
      <member refid="classHurricane_1_1Collection_1ae98948c714b5664e6fb3455a61c9ed3b" prot="public" virt="non-virtual"><scope>Hurricane::Collection</scope><name>empty</name></member>
      <member refid="classHurricane_1_1Collection_1abb40704519d3ff36ed1698dc648704ad" prot="public" virt="non-virtual"><scope>Hurricane::Collection</scope><name>end</name></member>
      <member refid="classHurricane_1_1Collection_1aeb2e8875b60cb6aad62f2c9640f1fa23" prot="public" virt="non-virtual"><scope>Hurricane::Collection</scope><name>fill</name></member>
      <member refid="classHurricane_1_1Collection_1a087a86e240e7695c8a00e8975cf4385a" prot="public" virt="non-virtual"><scope>Hurricane::Collection</scope><name>fill</name></member>
      <member refid="classHurricane_1_1Collection_1abaa7dac9adab0cb6025059cfd495e221" prot="public" virt="non-virtual"><scope>Hurricane::Collection</scope><name>fill</name></member>
      <member refid="classHurricane_1_1Collection_1a24420b64124ffee31c1cc296b33f015c" prot="public" virt="non-virtual"><scope>Hurricane::Collection</scope><name>fill</name></member>
      <member refid="classHurricane_1_1Collection_1ac75b91d3952b36e14f21174958523924" prot="public" virt="pure-virtual"><scope>Hurricane::Collection</scope><name>getClone</name></member>
      <member refid="classHurricane_1_1Collection_1a846a042646e02a0f77d2ce0f6190288a" prot="public" virt="non-virtual"><scope>Hurricane::Collection</scope><name>getFirst</name></member>
      <member refid="classHurricane_1_1Collection_1a48fd1a0a2b6d2530a87e22ba65aa3152" prot="public" virt="pure-virtual"><scope>Hurricane::Collection</scope><name>getLocator</name></member>
      <member refid="classHurricane_1_1Collection_1a9076419d7ee2359d16a46e4e6366a832" prot="public" virt="non-virtual"><scope>Hurricane::Collection</scope><name>getNotSubSet</name></member>
      <member refid="classHurricane_1_1Collection_1a1292aabe88c9aadfdfe21dabddb62c19" prot="public" virt="virtual"><scope>Hurricane::Collection</scope><name>getSize</name></member>
      <member refid="classHurricane_1_1Collection_1aa32ea7249d57ee05e3c71dcde8106832" prot="public" virt="non-virtual"><scope>Hurricane::Collection</scope><name>getSubSet</name></member>
      <member refid="classHurricane_1_1Collection_1a91d986e21395d4021d927e06f204ab6c" prot="public" virt="non-virtual"><scope>Hurricane::Collection</scope><name>getSubSet</name></member>
      <member refid="classHurricane_1_1Collection_1a673afd14782da82ad03a68366ae1f09b" prot="public" virt="non-virtual"><scope>Hurricane::Collection</scope><name>getSubSet</name></member>
      <member refid="classHurricane_1_1Collection_1a83b09bcd4c26dd4f3977c59c547da428" prot="public" virt="non-virtual"><scope>Hurricane::Collection</scope><name>isEmpty</name></member>
      <member refid="classHurricane_1_1Collection_1acf3eb413942b1edeb73550ce13c661fa" prot="private" virt="non-virtual"><scope>Hurricane::Collection</scope><name>operator=</name></member>
      <member refid="classHurricane_1_1Collection_1aafcf8e05658e245b2a762baa7a59f281" prot="public" virt="virtual"><scope>Hurricane::Collection</scope><name>~Collection</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
