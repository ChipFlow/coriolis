{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\info 
{\title {\comment Oroshi - Analog Devices Layout  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1.0 \par
}}Oroshi - Analog Devices Layout}
{\comment Generated byDoxgyen. }
{\creatim \yr2021\mo11\dy21\hr22\min10\sec22}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt Oroshi - Analog Devices Layout}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version 1.0\par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt Sun Nov 21 2021 }}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Hierarchical Index\par \pard\plain 
{\tc \v Hierarchical Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class Hierarchy\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This inheritance list is sorted roughly, but not completely, alphabetically:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
CapacitorUnit\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABF \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
CapacitorStack\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAA \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
RoutMatchedCapacitor\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
VerticalRoutingTracks\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACW \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
RoutMatchedCapacitor\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
RoutMatchedCapacitor\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
VerticalRoutingTracks\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Stack\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b CapacitorStack} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws the layout of a compact capacitor or a matrix of adjacent identical capacitors })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CapacitorUnit} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws a capacitor of type Poly-Poly or Metal-Metal in 350 nm AMS CMOS technology })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b RoutMatchedCapacitor} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Routs two matched capacitors, C1 and C2, drawn in a capacitor matrix })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Stack} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draw a {\b Stack} of Transistors })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b VerticalRoutingTracks} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Route two matched capacitors, C1 and C2, drawn in a capacitor matrix })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CapacitorStack Class Reference\par \pard\plain 
{\tc\tcl2 \v CapacitorStack}
{\xe \v CapacitorStack}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws the layout of a compact capacitor or a matrix of adjacent identical capacitors. }}\par
Inheritance diagram for CapacitorStack:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classpython_1_1capacitormatrix_1_1CapacitorStack__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b __init__} (self, device, capacitance, capacitorType, abutmentBoxPosition, nets, unitCap=0, matrixDim=[1, matchingMode=False, matchingScheme=[], dummyRing=False, dummyElement=False)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the class constructor. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b __isUnitCap__} (self)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b __isMatchingSchemeOK__} (self)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b capacitorIdOccurence} (self, capacitorIdentifier)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b create} (self, bbMode=False)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draw the compact or matrix of capacitors. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b capacitorLine} (self, dy, abutmentBox_spacing, matchingSchemeRowIndex=0)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Iteratively draws a horizontal or vertical line of capacitors according to the {\f2 direction}  parameter. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b capacitorMatrix} (self, abutmentBox_spacing=0)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws a matrix of identical capacitors. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b drawAbutmentBox} (self, abutmentBox_spacing=0)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws the abutment box of the matrix or campact capacitor. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b drawBottomPlatesRLayers} (self, bottomPlateRLayer, drawnCapacitor)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws the routing layers connecting the bottom plate in the matrix of capacitors. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b drawTopPlatesRLayers} (self, topPlateRLayer, drawnCapacitor)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws the routing layers connecting the top plates in the matrix of capacitors. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b getVerticalRoutingTrack_width} (self)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b getMatrixDim} (self)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b getMatchingScheme} (self)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws the layout of a compact capacitor or a matrix of adjacent identical capacitors. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The matrix can be composed of one type of capacitors, either Poly-Poly or Metal-Metal in 350 nm AMS CMOS technology. When matching mode is off, every adjacent plates of any consecutive elementary capacitors are connected to each other using vertical routing layers. Otherwise, when matching mode is on, any of elementary capacitors can belong to, $ C_1 $ or $ C_2 $ according to the entered matching scheme. Thus, routing is not done in this class. In both modes, the complete routing process is done using the {\f2 RoutCapacitor}  class. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v __init__\:python::capacitormatrix::CapacitorStack}
{\xe \v python::capacitormatrix::CapacitorStack\:__init__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def __init__ (  {\i self},   {\i device},   {\i capacitance},   {\i capacitorType},   {\i abutmentBoxPosition},   {\i nets},   {\i unitCap} = {\f2 0},   {\i matrixDim} = {\f2 [1},   {\i matchingMode} = {\f2 False},   {\i matchingScheme} = {\f2 []},   {\i dummyRing} = {\f2 False},   {\i dummyElement} = {\f2 False})}}
\par
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the class constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Basically, the class there are three categories of attributes. There are the ones related to the capacitor caracteristics, its type, dimensions. Also, there are attributes to parametrize the class into matching mode or not and there are other attributes realted to the layout varibales. The class has defaut input values, thus, in this constructor, there are two "sub-constructors" according to the entered input parameters. The class attributes are :\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i device} \cell }{The {\b Hurricane} AMS device into which the layout is drawn. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i capacitance} \cell }{The value of the capacitor, expressed in femto Farad (fF). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i capacitorType} \cell }{Can be MIM or PIP type capacitor. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i abutmentPosition} \cell }{Refers to the abscissa (XMin) of the bottom left corner of the abutment Box. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i abutmentBoxYMin} \cell }{Refers to the ordinate (YMin) of the bottom left corner of the abutment Box.\cell }
{\row }
}
Except the two last arguments, all the parameters are common with the CapacitorUnit class because the {\f2 {\b CapacitorStack}}  constructor calls the mother class constructor to create either a compact capacitor of {\f2 capacitance}  value or {\f2 rowNumber*}  {\f2 columnNumber}  unity capacitors.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rowNumber} \cell }{Number of rows in the matrix of capacitors. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i columnNumber} \cell }{Number of columns in the matrix of capacitors. \cell }
{\row }
}
}{
References CapacitorStack.__areInputDataOK__(), CapacitorUnit.__computeCapDim__(), CapacitorStack.__initGivenNonZeroUnitCap__(), CapacitorStack.__initGivenNonZeroUnitCapInMatchingMode__(), CapacitorStack.__initGivenZeroUnitCap__(), CapacitorStack.__initGivenZeroUnitCapInMatchingMode__(), CapacitorStack.__initMatrixMode__(), CapacitorUnit.__isCapacitorUnitOK__(), CapacitorUnit.abutmentBox, CapacitorStack.abutmentBox_spacing, CapacitorStack.abutmentBoxPosition, CapacitorStack.capacitance, CapacitorStack.capacitorIdOccurence(), CapacitorStack.capacitorsNumber, CapacitorUnit.capacitorType, CapacitorStack.compactCapDim, CapacitorStack.computeUnitCap(), CapacitorUnit.device, Stack.device, CapacitorStack.doMatrix, CapacitorStack.dummyElement, CapacitorStack.dummyRing, CapacitorStack.dummyRingPosition, CapacitorStack.evaluateUnitCap(), CapacitorStack.matchingMode, CapacitorStack.matchingScheme, CapacitorStack.matrixDim, CapacitorStack.minEnclosure_hRoutingLayer_topPlate_cut, CapacitorStack.minEnclosure_vRoutingTrackCut, CapacitorStack.minSpacing_vRoutingTrack, CapacitorStack.minSpacing_vRoutingTrackCut, CapacitorStack.minWidth_hRoutingLayer_topPlate_cut, CapacitorStack.minWidth_vRoutingTrack, CapacitorStack.minWidth_vRoutingTrackCut, CapacitorStack.nets, CapacitorStack.unitCapacitance, CapacitorStack.unitCapDim, and CapacitorStack.vRoutingTrack_width.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v __isUnitCap__\:python::capacitormatrix::CapacitorStack}
{\xe \v python::capacitormatrix::CapacitorStack\:__isUnitCap__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def __isUnitCap__ (  {\i self})}}
\par
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid True if the drawn capacitor is a compact one. This function is useful when an instance is called in another class. {\b Example}  : when the matrix or the compact capacitors are to be fully routed. \par
}}{
Referenced by RoutMatchedCapacitor.route().}\par
}
{\xe \v __isMatchingSchemeOK__\:python::capacitormatrix::CapacitorStack}
{\xe \v python::capacitormatrix::CapacitorStack\:__isMatchingSchemeOK__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def __isMatchingSchemeOK__ (  {\i self})}}
\par
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\f2 True}  if the matching scheme specifications are correct. Specifications are :{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Similar number of elements as total number of elementary capacitor in the matrix.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Equal number of affected capacitors to C1 as to C2.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Capacitor identifiers equal to '1' or '2' only.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Otherwise, the function returns {\f2 False} . \par}
}}{
References CapacitorStack.matchingScheme, and CapacitorStack.matrixDim.}\par
{
Referenced by CapacitorStack.capacitorIdOccurence().}\par
}
{\xe \v capacitorIdOccurence\:python::capacitormatrix::CapacitorStack}
{\xe \v python::capacitormatrix::CapacitorStack\:capacitorIdOccurence}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def capacitorIdOccurence (  {\i self},   {\i capacitorIdentifier})}}
\par
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid occurence of capacitor identifier in the entered matching scheme. This is useful to verify that {\f2 self.matchingScheme}  is correct. \par
}}{
References CapacitorStack.__areMatrixDimOK__(), CapacitorStack.__isMatchingSchemeOK__(), CapacitorStack.capacitorsNumber, CapacitorStack.dummyElement, CapacitorStack.dummyRing, CapacitorStack.matchingMode, CapacitorStack.matchingScheme, CapacitorStack.matrixDim, and CapacitorStack.nets.}\par
{
Referenced by CapacitorStack.__init__().}\par
}
{\xe \v create\:python::capacitormatrix::CapacitorStack}
{\xe \v python::capacitormatrix::CapacitorStack\:create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def create (  {\i self},   {\i bbMode} = {\f2 False})}}
\par
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draw the compact or matrix of capacitors. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
First, . Second, . Finally, . \par
}{
References CapacitorStack.__initMatchingMode__(), CapacitorStack.abutmentBox_spacing, CapacitorStack.abutmentBoxPosition, CapacitorStack.capacitance, CapacitorStack.capacitorMatrix(), CapacitorUnit.capacitorType, CapacitorStack.computeBondingBoxDimensions(), CapacitorUnit.device, Stack.device, CapacitorStack.doMatrix, CapacitorUnit.drawAbutmentBox(), CapacitorStack.drawBottomPlatesRLayers(), CapacitorStack.drawCapacitorStack(), CapacitorStack.drawTopPlatesRLayers(), CapacitorStack.dummyRing, CapacitorStack.matchingMode, CapacitorStack.matrixDim, CapacitorStack.nets, and CapacitorUnit.setRules().}\par
{
Referenced by CapacitorStack.capacitorLine(), and CapacitorStack.capacitorMatrix().}\par
}
{\xe \v capacitorLine\:python::capacitormatrix::CapacitorStack}
{\xe \v python::capacitormatrix::CapacitorStack\:capacitorLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def capacitorLine (  {\i self},   {\i dy},   {\i abutmentBox_spacing},   {\i matchingSchemeRowIndex} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Iteratively draws a horizontal or vertical line of capacitors according to the {\f2 direction}  parameter. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An exception is raised if the specified direction is different from {\f2 \{'horizontal'} ,'vertical'\}. At every iteration, an instance of the CapacitorUnit class is created and its layout is drawn. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid a list containing the drawn capacitors. \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dy} \cell }{the vertical position of the first cut in cut line. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remarks:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid An exception is raised if the specified direction is different from {\f2 \{'horizontal'} ,'vertical'\} \par
}}{
References CapacitorStack.abutmentBoxPosition, CapacitorUnit.capacitorType, CapacitorStack.create(), CapacitorStack.createElementInCapacitorLine(), CapacitorUnit.device, Stack.device, CapacitorStack.dummyRing, CapacitorStack.matchingMode, CapacitorStack.matchingScheme, CapacitorStack.matrixDim, CapacitorStack.nets, and CapacitorStack.unitCapacitance.}\par
{
Referenced by CapacitorStack.capacitorMatrix().}\par
}
{\xe \v capacitorMatrix\:python::capacitormatrix::CapacitorStack}
{\xe \v python::capacitormatrix::CapacitorStack\:capacitorMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def capacitorMatrix (  {\i self},   {\i abutmentBox_spacing} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws a matrix of identical capacitors. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The matrix is iterativelly constructed. At every iteration, a new horizontal line of capacitors is drawn. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid a nested list of elementary capacitors. \par
}}{
References CapacitorStack.abutmentBox_spacing, CapacitorStack.abutmentBoxPosition, CapacitorStack.capacitorLine(), CapacitorUnit.capacitorType, CapacitorStack.create(), CapacitorUnit.device, Stack.device, CapacitorStack.dummyRing, CapacitorStack.getCapDim(), CapacitorStack.matrixDim, CapacitorStack.nets, and CapacitorStack.unitCapacitance.}\par
{
Referenced by CapacitorStack.create().}\par
}
{\xe \v drawAbutmentBox\:python::capacitormatrix::CapacitorStack}
{\xe \v python::capacitormatrix::CapacitorStack\:drawAbutmentBox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def drawAbutmentBox (  {\i self},   {\i abutmentBox_spacing} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws the abutment box of the matrix or campact capacitor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
References CapacitorUnit.abutmentBox, CapacitorStack.abutmentBox_spacing, CapacitorStack.abutmentBoxPosition, CapacitorUnit.computeAbutmentBoxDimensions(), CapacitorUnit.device, and Stack.device.}\par
}
{\xe \v drawBottomPlatesRLayers\:python::capacitormatrix::CapacitorStack}
{\xe \v python::capacitormatrix::CapacitorStack\:drawBottomPlatesRLayers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def drawBottomPlatesRLayers (  {\i self},   {\i bottomPlateRLayer},   {\i drawnCapacitor})}}
\par
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws the routing layers connecting the bottom plate in the matrix of capacitors. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
First, the relative positions of the routing layer is of the is extracted from the elementary capacitor instance. Then, its width is computed in a way to connect adjacent plates. Then, the routing layers are iterativelly drawn. The two borders are . \par
}{
References CapacitorUnit.getBotPlateLeftRLayerXMax(), CapacitorUnit.getBotPlateRLayerWidth(), CapacitorUnit.getBotPlateRLayerYMax(), CapacitorUnit.getBottomPlateLeftCutXMin(), CapacitorUnit.getBottomPlateRightCutXMin(), CapacitorStack.matrixDim, and CapacitorStack.nets.}\par
{
Referenced by CapacitorStack.create().}\par
}
{\xe \v drawTopPlatesRLayers\:python::capacitormatrix::CapacitorStack}
{\xe \v python::capacitormatrix::CapacitorStack\:drawTopPlatesRLayers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def drawTopPlatesRLayers (  {\i self},   {\i topPlateRLayer},   {\i drawnCapacitor})}}
\par
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws the routing layers connecting the top plates in the matrix of capacitors. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
First, the relative positions of the routing layers is of the is extracted from the elementary capacitor instance. Then, its width is computed in a way to connect adjacent plates. Then, the routing layers are iterativelly drawn. The two borders are . \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remarks:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid An exception is raised if the number of rows in the matrix is lower than 2. \par
}}{
References CapacitorUnit.getTopPlateRLayerWidth(), CapacitorUnit.getTopPlateRLayerXCenter(), CapacitorUnit.getTopPlateRLayerYMax(), CapacitorUnit.getTopPlateRLayerYMin(), CapacitorStack.matrixDim, and CapacitorStack.nets.}\par
{
Referenced by CapacitorStack.create().}\par
}
{\xe \v getVerticalRoutingTrack_width\:python::capacitormatrix::CapacitorStack}
{\xe \v python::capacitormatrix::CapacitorStack\:getVerticalRoutingTrack_width}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def getVerticalRoutingTrack_width (  {\i self})}}
\par
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The width of the vertical routing tracks in matching mode. \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: This function is useful in matching mode, ie., in  RoutCapacitor class, when routing the two capacitors. \par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid \par
}}}
{\xe \v getMatrixDim\:python::capacitormatrix::CapacitorStack}
{\xe \v python::capacitormatrix::CapacitorStack\:getMatrixDim}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def getMatrixDim (  {\i self})}}
\par
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid A dictionary contaning capacitor matrix's dimensions \par
}}{
References CapacitorStack.compactCapDim, and CapacitorStack.doMatrix.}\par
}
{\xe \v getMatchingScheme\:python::capacitormatrix::CapacitorStack}
{\xe \v python::capacitormatrix::CapacitorStack\:getMatchingScheme}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def getMatchingScheme (  {\i self})}}
\par
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the matching scheme. The function is useful in {\f2 RoutMatchedCapacitor}  class to load {\f2 self.matchingScheme}  attribute. \par
}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
capacitormatrix.py\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CapacitorUnit Class Reference\par \pard\plain 
{\tc\tcl2 \v CapacitorUnit}
{\xe \v CapacitorUnit}
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws a capacitor of type Poly-Poly or Metal-Metal in 350 nm AMS CMOS technology. }}\par
Inheritance diagram for CapacitorUnit:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classpython_1_1capacitorunit_1_1CapacitorUnit__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b __init__} (self, device, capacitorType, abutmentBoxPosition, capacitance=0, capDim=\{\})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the class constructor. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b __setCapacitorPerUnit__} (self, capacitorType)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the area and perimeter capacitances as specified in 350 nm AMS technology and according to {\f2 capacitorType}  (MIM or PIP). }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b __computeCapDim__} (self, capacitance, capacitorType)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes width and length of the capacitor. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b __isCapacitorUnitOK__} (self, capDim)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if the computed capacitor dimensions exceed or are less than maximum and minimum limits, respectively, as specified in technology rules. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b setRules} (self)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Selects technological rules according to the capacitor type. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b getCapacitorType} (self)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b getMaximumCapWidth} (self)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
maximum size of capacitor's top plate. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b getMinimumCapWidth} (self)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b getLayers} (self)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Loads the technology file then extracts the adequate layers according to the capacitor type (MIM or PIP). }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b create} (self, t, b, bbMode=False, vEnclosure_botPlate_abtBox=None, hEnclosure_botPlate_abtBox=None)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When bonding box mode is activated, the function draws all layout physical layers of the capacitor after checking its dimensions. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b drawCapacitor} (self, layerDict, t, b)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws all layout physicial layers of the capacitor. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b computeBottomPlateCuts} (self)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes needed parameters to draw bottom plate cuts in its exact position, including : }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b computeTopPlateCuts} (self)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes needed parameters to draw top plate cuts in its exact position, including : }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b drawAbutmentBox} (self)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws the abutment box of the capacitor in position {\f2 <} (abutmentBoxXMin, abutmentBoxYMin)>. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b drawOnePlate} (self, layer, net, boxDimensions)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws the top or bottom plate through inflation of the Box under it. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b drawBottomPlateCut} (self, layer, b)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws the required cuts to connect the bottom plate. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b drawTopPlateCut} (self, layer, t)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws the top plate's cuts after computing the maximal number of cuts that can be placed and its exact enclosure in the top plate. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b drawRoutingLayers} (self, bottomPlateLayer, topPlateLayer, t, b)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws the routing layers of both bottom and top plates after computing widths and the exact position of these layers. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b cutMaxNumber} (self, width_layer, width_cut, spacing_cut, enclosure_cut)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes the maximal number of cuts to be placed on a layer of width {\f2 width_layer}  considering specifications such as the spacing between the cuts, its width and its enclosure in the layer. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b cutLine} (self, net, layer, firstCutXCenter, firstCutYCenter, width_cut, height_cut, spacing_cut, cutNumber, direction)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a horizontal or vertical line of contacts according to the specified direction. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b cutMatrix} (self, net, layer, firstCutXCenter, firstCutYCenter, width_cut, height_cut, spacing_cut, cutColumnNumber, cutRowNumber)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a matrix of cuts by vertically stacking horizontal lines of identical cuts. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b getBottomPlateYMax} (self)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b getBottomPlateLeftCutXMin} (self)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b getBottomPlateLeftCutYMin} (self)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b getBottomPlateLeftCutYMax} (self)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b getBottomPlateRightCutXMin} (self)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b getBottomPlateRightCutYMin} (self)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b getBottomPlateRightCutYMax} (self)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b getBotPlateLeftRLayerXMax} (self)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b getBottomPlateRightCutYCenter} (self)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b getBotPlateLeftRLayerXMin} (self)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b getBotPlateRLayerYMin} (self)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b getBotPlateRLayerYMax} (self)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b getBotPlateRLayerWidth} (self)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b getBotPlateRightRLayerXCenter} (self)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b getBotPlateLeftRLayerXCenter} (self)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b getTopPlateRLayerYMin} (self)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b getTopPlateRLayerYMax} (self)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b getTopPlateRLayerWidth} (self)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b getTopPlateRLayerXCenter} (self)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b getTopPlateRLayerXMin} (self)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b getTopPlateRLayerXMax} (self)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws a capacitor of type Poly-Poly or Metal-Metal in 350 nm AMS CMOS technology. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
PIP and MIM capacitors are the result of surface superposition between poly1 and poly2 or metal2 and metalcap layers, respectively. Given the capacitor value, layout dimensions are computed, then, capacitor layers are drawn. Capacitor value, $C$, is given in the expression below, where $ C_{a}, C_{p}, A $ and $ P $ are, area capacitance, perimeter capacitance, area and permiter of the capacitor, respectively : \[ C = C_{a}A + C_{p}P \] The drawn layout shape is square. Thus, metcap or poly2 length and width are equal and are computed using the capacitor expression. Furthermore, given $ C_{a} $, $ C_{p} $ and enclosure technological rules, dimensions and positions of the abutment box as well as the bottom plate are computed. Layouts with dimensions that exceed technological limits cannot be drawn. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v __init__\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:__init__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def __init__ (  {\i self},   {\i device},   {\i capacitorType},   {\i abutmentBoxPosition},   {\i capacitance} = {\f2 0},   {\i capDim} = {\f2 \{\}})}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the class constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Few of the class attributes final values are computed in this level. Most of attributes are only initialized to zero or empty values. Then, it is computed in dedicated class method. Input parameters are : {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i device} \cell }{{\b Hurricane} AMS device into which layout is drawn. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i capacitance} \cell }{Capacitor value, expressed in $ femto Farad (fF) $. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i abutmentBoxPosition} \cell }{A list containing abscissa and ordinate of the bottom left corner of the abutment box.\cell }
{\row }
}
Class attributes are described in the list below. Most of class attributes refer to layout dimensions. Dictionaries are used to group attributes related to the same layout varibale. Layout dimensions and variables are described in Figure 1.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i device} \cell }{{\b Hurricane} AMS device into which layout is drawn. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i capacitance} \cell }{Capacitor value, expressed in $ femto Farad (fF) $. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i capacitorType} \cell }{Can be 'MIMCap' or 'PIPCap' as capacitor type. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i abutmentBoxDict} \cell }{A dictionary containing abscissa and ordinate of the bottom left corner of the abutment box, (XMin) and (YMin), respectively. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i abutmentBox} \cell }{Abutment box drawn square. It is an object of type {\f2 Box} . \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bottomPlateBox} \cell }{Bottom plate drawn square. It is an object of type {\f2 Box} . \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i topPlateBox} \cell }{Top plate drawn square. It is an object of type {\f2 Box} . \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cut2MatrixDict} \cell }{A dictionary containing center position of the left bottom, which is cut the first to be drawn in the matrix of cuts. Initially, the dictionary is empty. It is only updated when {\f2 self.capacitorType}  is equal to {\f2 'MIMCap'} .\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cutLeftLineDict} \cell }{A dictionary containing abcissa and ordinate of the bottom cut in the left line of cuts to be drawn on bottom plate's layer. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cutRightLineDict} \cell }{A dictionary containing abcissa and ordinate of the bottom cut in the right line of cuts to be drawn on bottom plate's layer. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i topCutLineDict} \cell }{A dictionary containing abcissa and ordinate of the bottom cut in the right line of cuts to be drawn on top plate's layer. Initially, the dictionary is empty. It is only updated when {\f2 self.capacitorType}  is equal to {\f2 'PIPCap'} .\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i topPlateRLayerDict} \cell }{A dictionary containing position information of the top plate's routing layer. The dictionary includes ordinates of the layer's top and bottom extremities, {\f2 'XMin'}  and {\f2 'YMin'} , respectively, the abcissa of it's center, {\f2 'XCenter'}  and its width, {\f2 'width'} .\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bottomPlateRLayerDict} \cell }{A dictionary containing \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i enclosure_botPlate_topPlate} \cell }{Top plate's layer encolusre in bottom plate's layer. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i minheight_topPlatecut} \cell }{Minimum height of cuts for top plate connection to other metal layer. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i topCutLineNumber} \cell }{Maximum possible number cuts to be drawn for top plate's connection. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bottomCutLineNumber} \cell }{Maximum possible number cuts to be drawn for top plate's connection.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: Abutment box must be defined as an attribute because the position of dummy capacitor in {\f2 NonUnitCapacitor}  class must be precisely defined. \par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid \par
}}{
References CapacitorUnit.__computeCapacitance__(), CapacitorUnit.__computeCapDim__(), CapacitorUnit.__initCapDim__(), CapacitorUnit.abutmentBox, CapacitorUnit.abutmentBoxDict, CapacitorUnit.bottomCutLineNumber, CapacitorUnit.bottomPlateBox, CapacitorUnit.bottomPlateBoxDict, CapacitorUnit.bottomPlateRLayerDict, CapacitorUnit.capacitorType, CapacitorUnit.capDim, CapacitorUnit.cut2MatrixDict, CapacitorUnit.cutLeftLineDict, CapacitorUnit.cutRightLineDict, CapacitorUnit.device, Stack.device, CapacitorUnit.enclosure_botPlate_abtBox, CapacitorUnit.enclosure_botPlate_topPlate, CapacitorUnit.minheight_topPlatecut, CapacitorUnit.topCutLineDict, CapacitorUnit.topCutLineNumber, CapacitorUnit.topPlateBox, CapacitorUnit.topPlateBoxDict, and CapacitorUnit.topPlateRLayerDict.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v __setCapacitorPerUnit__\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:__setCapacitorPerUnit__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def __setCapacitorPerUnit__ (  {\i self},   {\i capacitorType})}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the area and perimeter capacitances as specified in 350 nm AMS technology and according to {\f2 capacitorType}  (MIM or PIP). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid a list containing the area and perimeter capacitances. \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remarks:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid An exception is raised if the entered capacitor type is unknown. \par
}}{
Referenced by CapacitorUnit.__computeCapDim__().}\par
}
{\xe \v __computeCapDim__\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:__computeCapDim__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def __computeCapDim__ (  {\i self},   {\i capacitance},   {\i capacitorType})}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes width and length of the capacitor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given {\f2 capacitance}  value as well as the permiter and area capacitances, a quadratic equation is solved where the unknown parameter is the width (also equivalent to the length). \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid a dictionary containing width and length. \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: The capacitor is square. Thus, length and width are equal. \par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid \par
}}{
References CapacitorUnit.__setCapacitorPerUnit__().}\par
{
Referenced by CapacitorStack.__init__(), and CapacitorUnit.__init__().}\par
}
{\xe \v __isCapacitorUnitOK__\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:__isCapacitorUnitOK__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def __isCapacitorUnitOK__ (  {\i self},   {\i capDim})}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if the computed capacitor dimensions exceed or are less than maximum and minimum limits, respectively, as specified in technology rules. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\f2 True}  if all rules are respected. \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: Maximum poly2 layer dimensions for PIP capacitor are not specified in technology rules. Thus, only minimum limit condition is checked. \par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid \par
}}{
References CapacitorUnit.capacitorType, CapacitorUnit.getMaximumCapWidth(), and CapacitorUnit.getMinimumCapWidth().}\par
{
Referenced by CapacitorStack.__init__(), and CapacitorUnit.create().}\par
}
{\xe \v setRules\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:setRules}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def setRules (  {\i self})}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Selects technological rules according to the capacitor type. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid a dictionary with rules labels as keys and rules as values. Example of technology rules are :{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
minimum spacing between cuts or metals,\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
minimum width of a plate, a cut or a routing metal.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
etc. Every rule takes two possible value according to the capacitor type (MIM or PIP). Therefore, dictionary keys are generic and its values are specific to the capacitor type. \par}
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: An exception is raised if the entered capacitor type is unknown. \par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid \par
}}{
References CapacitorUnit.capacitorType, CapacitorUnit.hpitch, CapacitorUnit.isVH, Stack.isVH, CapacitorUnit.METAL2Pitch, CapacitorUnit.metal2Width, CapacitorUnit.METAL3Pitch, CapacitorUnit.metal3Width, CapacitorUnit.minEnclo_botPlate_botPlateCut, CapacitorUnit.minEnclo_botPlateRMetal_botPlateCut, CapacitorUnit.minEnclo_routingTrackMetal_cut, CapacitorUnit.minEnclo_topPlate_topPlateCut, CapacitorUnit.minEnclo_topPlateRMetal_topPlateCut, CapacitorUnit.minheight_topPlatecut, CapacitorUnit.minSpacing_botPlate, CapacitorUnit.minSpacing_botPlateCut_topPlate, CapacitorUnit.minSpacingOnBotPlate_cut, CapacitorUnit.minSpacingOnTopPlate_cut, CapacitorUnit.minWidth_botPlatecut, CapacitorUnit.minWidth_botRMetal, CapacitorUnit.minWidth_routingTrackcut, CapacitorUnit.minWidth_topPlate, CapacitorUnit.minWidth_topPlatecut, CapacitorUnit.minWidth_topRMetal, and CapacitorUnit.vpitch.}\par
{
Referenced by CapacitorStack.create(), CapacitorUnit.create(), RoutMatchedCapacitor.route(), and VerticalRoutingTracks.setRules().}\par
}
{\xe \v getCapacitorType\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:getCapacitorType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def getCapacitorType (  {\i self})}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid capacitor type {\f2 'MIMCap'}  or {\f2 'PIPCap'} . \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remarks:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\f2 {\b getCapacitorType()}}  is especially useful when an instance of {\f2 {\b CapacitorUnit}}  class is called in another classes instances to identify the capacitor's type. \par
}}}
{\xe \v getMaximumCapWidth\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:getMaximumCapWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def getMaximumCapWidth (  {\i self})}}
\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
maximum size of capacitor's top plate. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 {\b getMaximumCapWidth()}}  is called to check if capacitor dimensions are within acceptable technological limits. An exception is raised if the entered capacitor type is unknown. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remarks:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 1. This function is especially usefull in drawing the layout of a unity capacitor, where it is important to garantee that the capacitor size does not exeed the maximum possible value. It is also useful when drawing a matrix of capacitors to make sure that also the unity capacitor respects the maximal values specified. \par
2. The maximum value of the poly2 size in PIP capacitor is not specified. Thus, it is not considered in {\f2 {\b getMaximumCapWidth()}}  \par
}}{
References CapacitorUnit.capacitorType.}\par
{
Referenced by CapacitorUnit.__isCapacitorUnitOK__().}\par
}
{\xe \v getMinimumCapWidth\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:getMinimumCapWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def getMinimumCapWidth (  {\i self})}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The minimum size of the capacitor's top plate. An exception is raised if the entered capacitor type is unknown. \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remarks:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid This function is especially usefull in drawing the layout of a matrix of capacitors where it is important to ensure that the unity capacitor respects the minimal values specified. \par
An exception is raised if the entered capacitor type is unknown. \par
}}{
References CapacitorUnit.capacitorType.}\par
{
Referenced by CapacitorUnit.__isCapacitorUnitOK__().}\par
}
{\xe \v getLayers\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:getLayers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def getLayers (  {\i self})}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Loads the technology file then extracts the adequate layers according to the capacitor type (MIM or PIP). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid a dictionary containing the layer labels as attributes and its values. \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remarks:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid An exception is raised if the entered capacitor type is unknown. \par
}}{
References CapacitorUnit.capacitorType.}\par
{
Referenced by CapacitorUnit.create().}\par
}
{\xe \v create\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def create (  {\i self},   {\i t},   {\i b},   {\i bbMode} = {\f2 False},   {\i vEnclosure_botPlate_abtBox} = {\f2 None},   {\i hEnclosure_botPlate_abtBox} = {\f2 None})}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When bonding box mode is activated, the function draws all layout physical layers of the capacitor after checking its dimensions. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All functions are excecuted in a new Update Session. In the contrary, only an exact estimation of layout dimensions is given. An error is raised when dimensions reach technological limits for MIM and PIP capacitors or when {\f2 bbMode}  parameters is other than {\f2 True}  or {\f2 False} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i (} \cell }{t , b ) nets of top and bottom plates, respectively \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bbMode} \cell }{activates bonding box dimensions computing when set to {\f2 True}  \cell }
{\row }
}
}{
References CapacitorUnit.__isCapacitorUnitOK__(), CapacitorUnit.abutmentBoxDict, CapacitorUnit.capDim, CapacitorUnit.computeDimensions(), Stack.computeDimensions(), CapacitorUnit.drawAbutmentBox(), CapacitorUnit.drawCapacitor(), Technology.getLayers(), CapacitorUnit.getLayers(), and CapacitorUnit.setRules().}\par
}
{\xe \v drawCapacitor\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:drawCapacitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def drawCapacitor (  {\i self},   {\i layerDict},   {\i t},   {\i b})}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws all layout physicial layers of the capacitor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i layerDict} \cell }{a dictionary containing a description of the required physical layers according to capacitor type \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i (} \cell }{t , b ) nets of top and bottom plates, respectively \cell }
{\row }
}
}{
References CapacitorUnit.bottomPlateBox, CapacitorUnit.bottomPlateBoxDict, CapacitorUnit.drawBottomPlateCut(), CapacitorUnit.drawOnePlate(), CapacitorUnit.drawRoutingLayers(), CapacitorUnit.drawTopPlateCut(), CapacitorUnit.topPlateBox, and CapacitorUnit.topPlateBoxDict.}\par
{
Referenced by CapacitorUnit.create().}\par
}
{\xe \v computeBottomPlateCuts\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:computeBottomPlateCuts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def computeBottomPlateCuts (  {\i self})}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes needed parameters to draw bottom plate cuts in its exact position, including : }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
maximum number of cuts to draw on both sides of bottom plate,\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
adjusted enclosure of\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
abcissas of the two bottom cuts on left and right sides of bottom plate,\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
ordinate of the same two cuts.\par}
Given parameters described above, it is possible to draw the entire lines of cuts on both sides of bottom plate using {\f2 cutLine}  function. \par
}{
References CapacitorUnit.bottomCutLineNumber, CapacitorUnit.bottomPlateBoxDict, CapacitorUnit.cutLeftLineDict, CapacitorUnit.cutMaxNumber(), CapacitorUnit.cutRightLineDict, CapacitorUnit.minEnclo_botPlate_botPlateCut, CapacitorUnit.minheight_topPlatecut, CapacitorUnit.minSpacing_botPlateCut_topPlate, CapacitorUnit.minSpacingOnBotPlate_cut, CapacitorUnit.minWidth_topPlatecut, and CapacitorUnit.topPlateBoxDict.}\par
{
Referenced by CapacitorUnit.drawAbutmentBox().}\par
}
{\xe \v computeTopPlateCuts\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:computeTopPlateCuts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def computeTopPlateCuts (  {\i self})}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes needed parameters to draw top plate cuts in its exact position, including : }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
maximum number of cuts to draw on both sides of top plate,\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
adjusted enclosure of\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
abcissas of the two top cuts on left and right sides of top plate,\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
ordinate of the same two cuts.\par}
Given parameters described above, it is possible to draw the entire lines of cuts on both sides of bottom plate using {\f2 cutLine}  function. \par
}{
References CapacitorUnit.abutmentBoxDict, CapacitorUnit.bottomPlateBoxDict, CapacitorUnit.bottomPlateRLayerDict, CapacitorUnit.capacitorType, CapacitorUnit.cut2MatrixDict, CapacitorUnit.cutLeftLineDict, CapacitorUnit.cutMaxNumber(), CapacitorUnit.cutRightLineDict, CapacitorUnit.enclosure_botPlate_topPlate, CapacitorUnit.hEnclosure_botPlate_abtBox, CapacitorUnit.minEnclo_botPlate_botPlateCut, CapacitorUnit.minEnclo_botPlateRMetal_botPlateCut, CapacitorUnit.minEnclo_routingTrackMetal_cut, CapacitorUnit.minEnclo_topPlate_topPlateCut, CapacitorUnit.minEnclo_topPlateRMetal_topPlateCut, CapacitorUnit.minheight_topPlatecut, CapacitorUnit.minSpacing_botPlate, CapacitorUnit.minSpacing_botPlateCut_topPlate, CapacitorUnit.minSpacingOnTopPlate_cut, CapacitorUnit.minWidth_botPlatecut, CapacitorUnit.minWidth_botRMetal, CapacitorUnit.minWidth_routingTrackcut, CapacitorUnit.minWidth_topPlatecut, CapacitorUnit.setBottomPlateAbtBoxEnclosure(), CapacitorUnit.topCutLineDict, CapacitorUnit.topCutLineNumber, CapacitorUnit.topPlateBoxDict, CapacitorUnit.topPlateRLayerDict, and CapacitorUnit.vEnclosure_botPlate_abtBox.}\par
{
Referenced by CapacitorUnit.drawAbutmentBox().}\par
}
{\xe \v drawAbutmentBox\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:drawAbutmentBox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def drawAbutmentBox (  {\i self})}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws the abutment box of the capacitor in position {\f2 <} (abutmentBoxXMin, abutmentBoxYMin)>. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
First, the minimum enclosure of the top plate inside the bottom plate is computed. Second, using this parameters as well as the capacitor dimensions, the width and height of the abutment box are computed. The box is finally drawn. \par
}{
References CapacitorUnit.abutmentBox, CapacitorUnit.abutmentBoxDict, CapacitorUnit.bottomPlateBoxDict, CapacitorUnit.computeAbutmentBoxDimensions(), CapacitorUnit.computeBottomPlateCuts(), CapacitorUnit.computeOnePlateBoxDimensions(), CapacitorUnit.computeRoutingLayersDimensions(), CapacitorUnit.computeTopPlateCuts(), CapacitorUnit.enclosure_botPlate_topPlate, CapacitorUnit.hEnclosure_botPlate_abtBox, CapacitorUnit.topPlateBoxDict, and CapacitorUnit.vEnclosure_botPlate_abtBox.}\par
{
Referenced by CapacitorStack.create(), and CapacitorUnit.create().}\par
}
{\xe \v drawOnePlate\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:drawOnePlate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def drawOnePlate (  {\i self},   {\i layer},   {\i net},   {\i boxDimensions})}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws the top or bottom plate through inflation of the Box under it. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
These boxes are the abutment box in the case of the bottom plate and the bottom plate's box in the case of the top plate. This function also creates a a net for the drawn plate and sets it as external. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The drawn box. \par
}}{
Referenced by CapacitorUnit.drawCapacitor().}\par
}
{\xe \v drawBottomPlateCut\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:drawBottomPlateCut}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def drawBottomPlateCut (  {\i self},   {\i layer},   {\i b})}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws the required cuts to connect the bottom plate. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
First, the maximal possible number of cuts that can be drawn is computed. Second, using the computed number, the enclosure of this cuts in the bottom plate's layer is adjusted while the minimal enclosure is respected. Third, the relative positions of the cuts on both sides of the plate are computed. Finally, two vertical lines of cuts are drawns. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: The relative positions describe the cordinates of the first bottom cut in every line of cuts. Then, knowing the spacing and width specifications of these cuts the rest of the line is easilly constructed. \par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid \par
}}{
References CapacitorUnit.bottomCutLineNumber, CapacitorUnit.cutLeftLineDict, CapacitorUnit.cutLine(), CapacitorUnit.cutRightLineDict, CapacitorUnit.minheight_topPlatecut, CapacitorUnit.minSpacingOnBotPlate_cut, and CapacitorUnit.minWidth_botPlatecut.}\par
{
Referenced by CapacitorUnit.drawCapacitor().}\par
}
{\xe \v drawTopPlateCut\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:drawTopPlateCut}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def drawTopPlateCut (  {\i self},   {\i layer},   {\i t})}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws the top plate's cuts after computing the maximal number of cuts that can be placed and its exact enclosure in the top plate. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
References CapacitorUnit.capacitorType, CapacitorUnit.cut2MatrixDict, CapacitorUnit.cutLine(), CapacitorUnit.cutMatrix(), CapacitorUnit.minheight_topPlatecut, CapacitorUnit.minSpacingOnTopPlate_cut, CapacitorUnit.minWidth_topPlatecut, CapacitorUnit.topCutLineDict, and CapacitorUnit.topCutLineNumber.}\par
{
Referenced by CapacitorUnit.drawCapacitor().}\par
}
{\xe \v drawRoutingLayers\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:drawRoutingLayers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def drawRoutingLayers (  {\i self},   {\i bottomPlateLayer},   {\i topPlateLayer},   {\i t},   {\i b})}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws the routing layers of both bottom and top plates after computing widths and the exact position of these layers. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Also computes positions if rlayers that are crucial for routing. \par
}{
References CapacitorUnit.bottomPlateRLayerDict, CapacitorUnit.cutLeftLineDict, CapacitorUnit.cutRightLineDict, and CapacitorUnit.topPlateRLayerDict.}\par
{
Referenced by CapacitorUnit.drawCapacitor().}\par
}
{\xe \v cutMaxNumber\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:cutMaxNumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def cutMaxNumber (  {\i self},   {\i width_layer},   {\i width_cut},   {\i spacing_cut},   {\i enclosure_cut})}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes the maximal number of cuts to be placed on a layer of width {\f2 width_layer}  considering specifications such as the spacing between the cuts, its width and its enclosure in the layer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Referenced by CapacitorUnit.computeBottomPlateCuts(), and CapacitorUnit.computeTopPlateCuts().}\par
}
{\xe \v cutLine\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:cutLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def cutLine (  {\i self},   {\i net},   {\i layer},   {\i firstCutXCenter},   {\i firstCutYCenter},   {\i width_cut},   {\i height_cut},   {\i spacing_cut},   {\i cutNumber},   {\i direction})}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a horizontal or vertical line of contacts according to the specified direction. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Referenced by CapacitorUnit.cutMatrix(), CapacitorUnit.drawBottomPlateCut(), and CapacitorUnit.drawTopPlateCut().}\par
}
{\xe \v cutMatrix\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:cutMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def cutMatrix (  {\i self},   {\i net},   {\i layer},   {\i firstCutXCenter},   {\i firstCutYCenter},   {\i width_cut},   {\i height_cut},   {\i spacing_cut},   {\i cutColumnNumber},   {\i cutRowNumber})}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a matrix of cuts by vertically stacking horizontal lines of identical cuts. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i net} \cell }{net to which the cuts belong \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i layer} \cell }{cuts physical layer \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i firstCutXCenter} \cell }{center's abcissa of the bottom left cut ( that is the first cut to be drawn in the matrix ) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i firstCutYCenter} \cell }{center's abcissa of the bottom left cut \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i (width_cut,height_cut,spacing_cut)} \cell }{cuts dimenions \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i (cutColumnNumber,cutRowNumber)} \cell }{matrix dimensions\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remarks:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The matrix can have any dimensions zero or negative one. \par
}}{
References CapacitorUnit.cutLine().}\par
{
Referenced by CapacitorUnit.drawTopPlateCut().}\par
}
{\xe \v getBottomPlateYMax\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:getBottomPlateYMax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def getBottomPlateYMax (  {\i self})}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the ordinate of the bottom plate's highest end-point ( that is equivalent to {\f2 dySource}  of the bottom plate's box ) . \par
}}{
References CapacitorUnit.bottomPlateBoxDict.}\par
}
{\xe \v getBottomPlateLeftCutXMin\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:getBottomPlateLeftCutXMin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def getBottomPlateLeftCutXMin (  {\i self})}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the abcissa of the bottom plate's left line of cuts. \par
}}{
Referenced by CapacitorStack.drawBottomPlatesRLayers(), and RoutMatchedCapacitor.drawCuts_vRoutingTrack_hRoutingTrack().}\par
}
{\xe \v getBottomPlateLeftCutYMin\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:getBottomPlateLeftCutYMin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def getBottomPlateLeftCutYMin (  {\i self})}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the ordinate of the first ( or bottom) cut in the left line of cuts on the bottom plate. \par
}}}
{\xe \v getBottomPlateLeftCutYMax\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:getBottomPlateLeftCutYMax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def getBottomPlateLeftCutYMax (  {\i self})}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the ordinate of the highest cut of the bottom plate's left line of cuts. \par
}}{
References CapacitorUnit.bottomCutLineNumber, CapacitorUnit.minSpacingOnBotPlate_cut, and CapacitorUnit.minWidth_botPlatecut.}\par
}
{\xe \v getBottomPlateRightCutXMin\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:getBottomPlateRightCutXMin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def getBottomPlateRightCutXMin (  {\i self})}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the absissa of the bottom plate's right line of cuts. \par
}}{
Referenced by CapacitorStack.drawBottomPlatesRLayers(), and RoutMatchedCapacitor.drawCuts_vRoutingTrack_hRoutingTrack().}\par
}
{\xe \v getBottomPlateRightCutYMin\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:getBottomPlateRightCutYMin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def getBottomPlateRightCutYMin (  {\i self})}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the ordinate of the first ( or bottom) cut in the right line of cuts on the bottom plate. \par
}}{
Referenced by RoutMatchedCapacitor.computeHRLayerYCenter(), and CapacitorUnit.getBottomPlateRightCutYCenter().}\par
}
{\xe \v getBottomPlateRightCutYMax\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:getBottomPlateRightCutYMax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def getBottomPlateRightCutYMax (  {\i self})}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the ordinate of the highest ( or top) cut in the right line of cuts on the bottom plate. \par
}}{
References CapacitorUnit.bottomCutLineNumber, CapacitorUnit.minSpacingOnBotPlate_cut, and CapacitorUnit.minWidth_botPlatecut.}\par
{
Referenced by RoutMatchedCapacitor.computeHRLayerYCenter(), and CapacitorUnit.getBottomPlateRightCutYCenter().}\par
}
{\xe \v getBotPlateLeftRLayerXMax\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:getBotPlateLeftRLayerXMax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def getBotPlateLeftRLayerXMax (  {\i self})}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the center's ordinate of the bottom plate's left cut (the cut that is the first one in the line). \par
}}{
Referenced by CapacitorStack.drawBottomPlatesRLayers().}\par
}
{\xe \v getBottomPlateRightCutYCenter\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:getBottomPlateRightCutYCenter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def getBottomPlateRightCutYCenter (  {\i self})}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the position of the bottom plate's right cuts on the horitontal axis (also applicable to left cuts). \par
}}{
References CapacitorUnit.getBottomPlateRightCutYMax(), and CapacitorUnit.getBottomPlateRightCutYMin().}\par
}
{\xe \v getBotPlateLeftRLayerXMin\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:getBotPlateLeftRLayerXMin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def getBotPlateLeftRLayerXMin (  {\i self})}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the position of the bottom plate's left cuts on the horitontal axis. \par
}}}
{\xe \v getBotPlateRLayerYMin\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:getBotPlateRLayerYMin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def getBotPlateRLayerYMin (  {\i self})}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the position of bottom plate's left cuts on the horitontal axis. \par
}}{
Referenced by RoutMatchedCapacitor.route().}\par
}
{\xe \v getBotPlateRLayerYMax\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:getBotPlateRLayerYMax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def getBotPlateRLayerYMax (  {\i self})}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the position of bottom plate's left cuts on the horitontal axis. \par
}}{
Referenced by CapacitorStack.drawBottomPlatesRLayers().}\par
}
{\xe \v getBotPlateRLayerWidth\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:getBotPlateRLayerWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def getBotPlateRLayerWidth (  {\i self})}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the position of bottom plate's left cuts on the horitontal axis. \par
}}{
Referenced by CapacitorStack.drawBottomPlatesRLayers(), RoutMatchedCapacitor.drawCuts_vRoutingTrack_hRoutingTrack(), and RoutMatchedCapacitor.route().}\par
}
{\xe \v getBotPlateRightRLayerXCenter\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:getBotPlateRightRLayerXCenter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def getBotPlateRightRLayerXCenter (  {\i self})}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the position of bottom plate's left cuts on the horitontal axis. \par
}}{
Referenced by RoutMatchedCapacitor.route().}\par
}
{\xe \v getBotPlateLeftRLayerXCenter\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:getBotPlateLeftRLayerXCenter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def getBotPlateLeftRLayerXCenter (  {\i self})}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the position of bottom plate's left cuts on the horitontal axis. \par
}}{
Referenced by RoutMatchedCapacitor.route().}\par
}
{\xe \v getTopPlateRLayerYMin\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:getTopPlateRLayerYMin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def getTopPlateRLayerYMin (  {\i self})}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the ordinate of the bottom end points of the top plate routing layer. \par
}}{
Referenced by CapacitorStack.drawTopPlatesRLayers(), and RoutMatchedCapacitor.route().}\par
}
{\xe \v getTopPlateRLayerYMax\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:getTopPlateRLayerYMax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def getTopPlateRLayerYMax (  {\i self})}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the ordinate of the higher end points of the top plate routing layer. \par
}}{
Referenced by CapacitorStack.drawTopPlatesRLayers().}\par
}
{\xe \v getTopPlateRLayerWidth\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:getTopPlateRLayerWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def getTopPlateRLayerWidth (  {\i self})}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the width of top plate's routing layer. \par
}}{
Referenced by RoutMatchedCapacitor.drawCuts_vRoutingTrack_hRoutingTrack(), CapacitorStack.drawTopPlatesRLayers(), and RoutMatchedCapacitor.route().}\par
}
{\xe \v getTopPlateRLayerXCenter\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:getTopPlateRLayerXCenter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def getTopPlateRLayerXCenter (  {\i self})}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the center's abcissa of the bottom plate routing layer. \par
}}{
Referenced by CapacitorStack.drawTopPlatesRLayers().}\par
}
{\xe \v getTopPlateRLayerXMin\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:getTopPlateRLayerXMin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def getTopPlateRLayerXMin (  {\i self})}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the origin (bottom-left end point) abcissa of the top plate routing layers. \par
}}{
References CapacitorUnit.topPlateRLayerDict.}\par
{
Referenced by RoutMatchedCapacitor.__computeConnections__(), and RoutMatchedCapacitor.drawCuts_vRoutingTrack_hRoutingTrack().}\par
}
{\xe \v getTopPlateRLayerXMax\:python::capacitorunit::CapacitorUnit}
{\xe \v python::capacitorunit::CapacitorUnit\:getTopPlateRLayerXMax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def getTopPlateRLayerXMax (  {\i self})}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the abscissa of the bottom-right end-point of the top plate routing layer. \par
}}{
References CapacitorUnit.topPlateRLayerDict.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
capacitorunit.py\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RoutMatchedCapacitor Class Reference\par \pard\plain 
{\tc\tcl2 \v RoutMatchedCapacitor}
{\xe \v RoutMatchedCapacitor}
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Routs two matched capacitors, C1 and C2, drawn in a capacitor matrix. }}\par
Inheritance diagram for RoutMatchedCapacitor:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classpython_1_1capacitorrouted_1_1RoutMatchedCapacitor__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b __init__} (self, vRTInstance)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A special method used to customize the class instance to an initial state in which : }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b route} (self, bbMode=False)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws the complete layout given the capacitor matrix. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b setRules} (self)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines technology rules used to draw the layout. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b setLayers} (self)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines all physical layers used to draw the layout. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b computeDimensions} (self, bbMode)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes, through simple instructions and functions calls, layout variables detailed in Figure 2. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b computeHRoutingTrackYCenter} (self)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes centers' ordinates of the eight horizontal routing tracks. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b computeHRLayerYCenter} (self)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the stretching value of top plates. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b drawHRoutingTracks} (self, routingTracksLayer)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Iteratively draws horizontal routing tracks on top and bottom positions of the matrix using physical layer {\f2 routingTracksLayer} . }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b drawHRLayers} (self, xPlateRLayer)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Iteratively draws the horizontal routing layers starting with bottom left elementary capacitor $ C_{00} $. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b drawCuts} (self, layer_hRTrack_hRLayer, layer_tracksCut, layer_topPlateCut)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws all required cuts using physical layers : }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b drawOneCut_vRoutingTrack_HRLayer} (self, net, cutLayer, cutXMin, cutYMin, cutNumber)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws one cut, in layer {\f2 cutLayer} , in order to connect a vertical routing track, at position {\f2 cutXMin}  in metal 2, and a horizontal routing track, at position {\f2 cutYMin}  in metal 3. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b drawCuts_vRoutingTrack_hRoutingTrack} (self, cutLayer, cutNumber, enclosure_cut)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws cuts to connect vertical routing tracks in metal 2 and horizontal routing tracks in metal 3. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b __stretchTopPlates__} (self, capacitor, rlayer)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Iteratively performs top plates stretching for the capacitor matrix. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b __stretchTopPlateCompactCap__} (self, net, capacitor, routingLayer, j=0)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws vertical stretched layers for a given elementary capacitor. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b __setStretchingDySourceDyTarget__} (self, capacitor, deltay)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the abcissas of the extremities of the vertical stretching to be applied to capacitor's top plates for a given elementary capacitor in the matrix. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b __computeConnections__} (self, i, j, capacitorIdentifier)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes horizontal routing layers source and target abcissas for top and bottom plates connections to its associated routing track. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Routs two matched capacitors, C1 and C2, drawn in a capacitor matrix. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connections are put in place with reference to a given matching scheme. Elementary capacitor units are connected to horizontal and vertical routing tracks that represent top plates and bottom plates nets of C1 and C2 . Supported types of capacitors are Poly-Poly and Metal-Metal. Technologycal rules are provided by 350 nm AMS CMOS technology with three-four metal layers. Metal layers that are used for routing are placed similarly to horziontal-vertical (HV) symbolic Alliance CAD tool router, where horizontal metal channels are drawn in metal 2 and the vertical ones are in metal 3. Given a matrix of dimensions $ R*C $, the total number of vertical tracks is $ 2C+2 $ equivalent to $ C+1 $ couples, ensuring that every elementary capacitor is positioned between four vertical tracks, two from each side. In fact, every adjacent couple of these tracks represent top plates and bottom plates of C1 or C2 as shown in Figure 1.  An elementary capacitor unit can be a part of C1 or C2 according to the matching scheme. However, to respect common-centroid layout specifications, for C1 and C2 to be equal, the matrix number of colums and number of rows must be both even. Addionnally, the number of elementary capacitors dedicated to C1 must be equal to those dedicated to C2. These two conditions are tested in one of the class methods. An exception is raised if at least one of the two is not respected. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v __init__\:python::capacitorrouted::RoutMatchedCapacitor}
{\xe \v python::capacitorrouted::RoutMatchedCapacitor\:__init__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def __init__ (  {\i self},   {\i vRTInstance})}}
\par
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A special method used to customize the class instance to an initial state in which : }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
the class attirbutes describing positions and dimensions of the layout are computed in dedicated class methods,\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
the attributes related to the capacitor matrix are copied from the {\f2 CapacitorStack}  instance.\par}
Position and dimensions attributes, also refered by layout variables, in Figure 2, are defined below : {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i device} \cell }{The {\b Hurricane} AMS device onto which the layout is drawn. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i capacitorInstance} \cell }{Instance of {\f2 CapacitorStack}  class. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i capacitor} \cell }{A nested list containing the matrix elements, which are {\f2 CapacitorUnit}  objects. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i matchingScheme} \cell }{A nested list, with equal dimensions as {\f2 capacitor}  attribute, containing assignements of matrix elementary units to C1 and C2, identified by 1 and 2, respectively. Therefore, {\f2 self.matchingScheme}  content is a succession of 1 and 2 values, defined as \\ capacitor identifiers. For example, given a matrix of dimensions 2x2, the matching scheme can be $ [ [1,2], [1,2] ] or [ [2,1], [2,1] ] $. The first sub-list dictates that the first elementary capacitor, $ C_{00} $. The second element $ C_{01} $ is affected to C2 and so on. An immediate and obvious consequence to this, is that an error is raised if {\f2 self.matchingSchem}  and {\f2 self.capacitor}  dimensions are not identical or if {\f2 self.matchingScheme}  content is different from supported capacitor identifiers, '1' and '2'.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i capacitorType} \cell }{Supported types of capacitors are MIM and PIP only. An exception is raised otherwise. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i abutmentBox} \cell }{The matrix's abutment box. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i matrxiDim} \cell }{The matrix dimensions, also equal to {\f2 self.matchingScheme}  nested list dimensions. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i abutmentBox_spacing} \cell }{The spacing between elementary units in the matrix. It is computed in {\f2 CapacitorStack}  and is reloaded in {\f2 {\b RoutMatchedCapacitor}} . {\f2 self.abutmentBox_spacing}  includes, vertical routing tracks width and minimum allowed spacing between two adjacent ones. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i hRoutingLayer_width} \cell }{The width of horizontal routing layers in metal 2, which connect capacitors plates to vertical routing tracks. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vRoutingTrack_width} \cell }{The width of vertical routing tracks in metal 3, which connects identical nets together ( ie : bottom plates of C1, top plates of C2, bottom plates of C2 and top plates of C2 ). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i hRoutingTrack_width} \cell }{The width of horizontal routing tracks in metal 2, which connect identical vertical routing tracks together. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i minSpacing_hRoutingTrack} \cell }{Minimum spacing between horizontal routing tracks. Wide metal 2 specifications are considered since metal 2 dimensions may exceed 10 $ m$.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: For more information about wide metal specifications, refer to ENG-183_rev8.pdf technology manual. \par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i minimumPosition} \cell }{The ordinate of the top plate's routing layer's bottom extremity after stretching. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i maximumPosition} \cell }{The ordinate of the top plate's routing layer's top extremity, also equivalent to the top plate's top extremity. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vRoutingTrackXCenter} \cell }{A nested list of ordered dictionaries, with dimensions equal to {\f2 self.matrixDim} , containing abcissas of vertical routing tracks. All sub-lists' lengths are identical and are equal to 2. The first and second elements describe position of top plate track and bottom plate track, respectively. For example, given a matrix of dimensions 2x2, {\f2 self.vRoutingTrackXCenter}  can be [[0, 2], [4,6], [8,10]] $ \mu m$. Elements of this nested list have particular indexing as described in Figure 2.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i hRoutingtrackYCenter} \cell }{A nested dictonary containing two keys, {\f2 topTracks}  and {\f2 bottomTracks} . Each key contains as value a dictionary describing centers' ordinates of four parallel horizontal tracks. The reason why four tracks are needed on top and bottom positions of the matrix is that four nets are used, two for every capacitor {\f2 Ci} , were {\f2 i}  is in [1,2]. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i hRoutingLayerYCenter} \cell }{A nested dicitonary containing two keys, {\f2 top}  and {\f2 bottom} . Each key contains as value a dictionary describing centers' ordinates of horizontal routing layers. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vRoutingTrackDict} \cell }{A dictionary of routing tracks top and bottom extremities ordinates. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i topPlateStretching} \cell }{Since not only the same metal 2 layer is used to draw top/bottom plates connections to vertical tracks but also the two plates are superimposed, the top plate's routing tracks is stretched. {\f2 self.topPlateStretching}  is therefore the length added to top plate's routing layer in order to avoid short circuits between top and bottom plates routing to vertical tracks since the same metal is used for both. \cell }
{\row }
}
}{
References RoutMatchedCapacitor.capacitor, CapacitorStack.dummyRing, RoutMatchedCapacitor.dummyRingCapacitor, RoutMatchedCapacitor.hRoutingLayer_width, RoutMatchedCapacitor.hRoutingLayerYCenter, RoutMatchedCapacitor.hRoutingTrack_width, RoutMatchedCapacitor.hRoutingtrackYCenter, CapacitorStack.matrixDim, RoutMatchedCapacitor.maximumPosition, RoutMatchedCapacitor.minimumPosition, RoutMatchedCapacitor.minSpacing_hRoutingTrack, RoutMatchedCapacitor.topPlateStretching, and RoutMatchedCapacitor.vRTInstance.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v route\:python::capacitorrouted::RoutMatchedCapacitor}
{\xe \v python::capacitorrouted::RoutMatchedCapacitor\:route}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def route (  {\i self},   {\i bbMode} = {\f2 False})}}
\par
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws the complete layout given the capacitor matrix. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 route}  method is succession of calls to user-defined methods inside a newly created {\f2 Updatesession} . The following tasks are excecuted :{
\par
\pard\plain \s91\fi-360\li720\widctlpar\fs20\cgrid 
1.\tab A nex {\f2 UpdateSession}  is created,\par
\pard\plain \s91\fi-360\li720\widctlpar\fs20\cgrid 
2.\tab all required physical layers are loaded,\par
\pard\plain \s91\fi-360\li720\widctlpar\fs20\cgrid 
3.\tab technology rules are defined according to capacitor type,\par
\pard\plain \s91\fi-360\li720\widctlpar\fs20\cgrid 
4.\tab layout dimension parameters are computed,\par
\pard\plain \s91\fi-360\li720\widctlpar\fs20\cgrid 
5.\tab routing tracks and layers are drawn,\par
\pard\plain \s91\fi-360\li720\widctlpar\fs20\cgrid 
6.\tab top plates are stretched,\par
\pard\plain \s91\fi-360\li720\widctlpar\fs20\cgrid 
7.\tab all required cuts are drawn,\par
\pard\plain \s91\fi-360\li720\widctlpar\fs20\cgrid 
8.\tab The {\f2 UpdateSession}  is closed.\par}
Meanwhile, an exception is raised when the entered {\f2 capacitor}  is not a capacitor matrix or if the capacitor type is unsupported. \par
}{
References CapacitorStack.__isUnitCap__(), RoutMatchedCapacitor.__stretchTopPlates__(), CapacitorUnit.abutmentBox, RoutMatchedCapacitor.capacitor, VerticalRoutingTracks.capacitorInstance, CapacitorUnit.computeDimensions(), Stack.computeDimensions(), CapacitorUnit.device, Stack.device, RoutMatchedCapacitor.drawCuts(), RoutMatchedCapacitor.drawDummyRing_hRTracks_Cuts(), RoutMatchedCapacitor.drawHRLayers(), RoutMatchedCapacitor.drawHRoutingTracks(), CapacitorStack.dummyRing, RoutMatchedCapacitor.dummyRingCapacitor, CapacitorUnit.getBotPlateLeftRLayerXCenter(), CapacitorUnit.getBotPlateRightRLayerXCenter(), CapacitorUnit.getBotPlateRLayerWidth(), CapacitorUnit.getBotPlateRLayerYMin(), CapacitorUnit.getTopPlateRLayerWidth(), CapacitorUnit.getTopPlateRLayerYMin(), VerticalRoutingTracks.getVTrackYMax(), VerticalRoutingTracks.getVTrackYMin(), CapacitorUnit.hpitch, RoutMatchedCapacitor.hRoutingtrackYCenter, CapacitorStack.matchingScheme, CapacitorStack.matrixDim, RoutMatchedCapacitor.maximumPosition, CapacitorUnit.metal3Width, RoutMatchedCapacitor.minimumPosition, CapacitorStack.nets, RoutMatchedCapacitor.routeDummyRing(), RoutMatchedCapacitor.routeLeftAndRightSides(), RoutMatchedCapacitor.routeTopOrBottomSide(), RoutMatchedCapacitor.setLayers(), CapacitorUnit.setRules(), CapacitorUnit.vpitch, CapacitorStack.vRoutingTrack_width, and RoutMatchedCapacitor.vRoutingTrackXCenter.}\par
}
{\xe \v setRules\:python::capacitorrouted::RoutMatchedCapacitor}
{\xe \v python::capacitorrouted::RoutMatchedCapacitor\:setRules}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def setRules (  {\i self})}}
\par
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines technology rules used to draw the layout. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Some of the rules, namely those describing routing layers and tracks are applicable for both MIM and PIP capacitors. However, cuts rules are different.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: All {\f2 CapacitorStack}  class rules are also reloaded in this class.\par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid An exception is raised if the entered capacitor type is unsupported.\par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid a dictionary with rules labels as keys and rules content as values. \par
}}{
References CapacitorUnit.capacitorType, CapacitorStack.minEnclosure_hRoutingLayer_topPlate_cut, RoutMatchedCapacitor.minSpacing_hRoutingLayer, RoutMatchedCapacitor.minSpacing_hRoutingLayer_topPlate_cut, RoutMatchedCapacitor.minSpacing_hRoutingLayer_vRoutingTrack_cut, RoutMatchedCapacitor.minSpacing_hRoutingTrackCut, CapacitorStack.minSpacing_vRoutingTrackCut, and CapacitorStack.minWidth_hRoutingLayer_topPlate_cut.}\par
}
{\xe \v setLayers\:python::capacitorrouted::RoutMatchedCapacitor}
{\xe \v python::capacitorrouted::RoutMatchedCapacitor\:setLayers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def setLayers (  {\i self})}}
\par
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines all physical layers used to draw the layout. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Layers are loaded using {\f2 DataBase}  API. The same routing layers are used for both capacitor types except cuts layers that connect top plates to vertical routing tracks. Basicaly, metal 2, meta 3, cut 1 and cut 2 are the ones defined. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid a dictionary composed of layers labels as keys and layers as values. \par
}}{
References CapacitorUnit.capacitorType, and CapacitorStack.dummyRing.}\par
{
Referenced by RoutMatchedCapacitor.route().}\par
}
{\xe \v computeDimensions\:python::capacitorrouted::RoutMatchedCapacitor}
{\xe \v python::capacitorrouted::RoutMatchedCapacitor\:computeDimensions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def computeDimensions (  {\i self},   {\i bbMode})}}
\par
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes, through simple instructions and functions calls, layout variables detailed in Figure 2. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
References CapacitorStack.abutmentBox_spacing, VerticalRoutingTracks.capacitorInstance, CapacitorStack.capacitorsNumber, RoutMatchedCapacitor.computeBondingBoxDimInbbMode(), RoutMatchedCapacitor.computeHRLayerYCenter(), RoutMatchedCapacitor.computeHRoutingTrackYCenter(), RoutMatchedCapacitor.hRoutingLayer_width, CapacitorStack.matrixDim, RoutMatchedCapacitor.maximumPosition, CapacitorStack.minEnclosure_hRoutingLayer_topPlate_cut, VerticalRoutingTracks.minEnclosure_hRoutingLayer_vRoutingTrack_cut, RoutMatchedCapacitor.minimumPosition, VerticalRoutingTracks.minWidth_hRoutingLayer, CapacitorStack.minWidth_hRoutingLayer_topPlate_cut, VerticalRoutingTracks.minWidth_hRoutingLayer_vRoutingTrack_cut, RoutMatchedCapacitor.vRoutingTrack_spacing, CapacitorStack.vRoutingTrack_width, RoutMatchedCapacitor.vRoutingTrackDict, RoutMatchedCapacitor.vRoutingTrackXCenter, and RoutMatchedCapacitor.vRTInstance.}\par
}
{\xe \v computeHRoutingTrackYCenter\:python::capacitorrouted::RoutMatchedCapacitor}
{\xe \v python::capacitorrouted::RoutMatchedCapacitor\:computeHRoutingTrackYCenter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def computeHRoutingTrackYCenter (  {\i self})}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes centers' ordinates of the eight horizontal routing tracks. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The tracks include four on top and four on bottom of the matrix. To do the computations, fist, center of the first bottom or top track, given in Figure 2, is computed. Then, all adjacent three centers are deduced by simples translation of the first one. Translation quantity is equal to the sum of distance between adjacent routing tracks, self.hRoutingTracks_spacing, and half width of the routing track itself, {\f2 self.hRoutingTrack_width} . \par
}{
References RoutMatchedCapacitor.__setPlatesIds__(), CapacitorUnit.hpitch, RoutMatchedCapacitor.hRoutingtrackYCenter, RoutMatchedCapacitor.maximumPosition, and RoutMatchedCapacitor.minimumPosition.}\par
{
Referenced by RoutMatchedCapacitor.computeDimensions().}\par
}
{\xe \v computeHRLayerYCenter\:python::capacitorrouted::RoutMatchedCapacitor}
{\xe \v python::capacitorrouted::RoutMatchedCapacitor\:computeHRLayerYCenter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def computeHRLayerYCenter (  {\i self})}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the stretching value of top plates. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Then iteratively computes the centers of horizontal routing layer regarding top and bottom plates. \par
}{
References RoutMatchedCapacitor.__findPossibleShortCircuits__(), VerticalRoutingTracks.__setStretching__(), RoutMatchedCapacitor.__setStretchingDySourceDyTarget__(), RoutMatchedCapacitor.bondingBox, RoutMatchedCapacitor.capacitor, CapacitorUnit.getBottomPlateRightCutYMax(), CapacitorUnit.getBottomPlateRightCutYMin(), RoutMatchedCapacitor.hRoutingLayer_width, RoutMatchedCapacitor.hRoutingLayerYCenter, RoutMatchedCapacitor.hRoutingTrack_width, RoutMatchedCapacitor.hRoutingtrackYCenter, CapacitorStack.matrixDim, RoutMatchedCapacitor.minSpacing_hRoutingLayer, RoutMatchedCapacitor.topPlateStretching, CapacitorStack.vRoutingTrack_width, and RoutMatchedCapacitor.vRoutingTrackXCenter.}\par
{
Referenced by RoutMatchedCapacitor.computeDimensions().}\par
}
{\xe \v drawHRoutingTracks\:python::capacitorrouted::RoutMatchedCapacitor}
{\xe \v python::capacitorrouted::RoutMatchedCapacitor\:drawHRoutingTracks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def drawHRoutingTracks (  {\i self},   {\i routingTracksLayer})}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Iteratively draws horizontal routing tracks on top and bottom positions of the matrix using physical layer {\f2 routingTracksLayer} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
References CapacitorUnit.device, Stack.device, RoutMatchedCapacitor.hRoutingTrack_width, RoutMatchedCapacitor.hRoutingtrackYCenter, CapacitorStack.nets, and RoutMatchedCapacitor.vRoutingTrackXCenter.}\par
{
Referenced by RoutMatchedCapacitor.route().}\par
}
{\xe \v drawHRLayers\:python::capacitorrouted::RoutMatchedCapacitor}
{\xe \v python::capacitorrouted::RoutMatchedCapacitor\:drawHRLayers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def drawHRLayers (  {\i self},   {\i xPlateRLayer})}}
\par
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Iteratively draws the horizontal routing layers starting with bottom left elementary capacitor $ C_{00} $. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
References RoutMatchedCapacitor.__computeConnections__(), RoutMatchedCapacitor.hRoutingLayer_width, RoutMatchedCapacitor.hRoutingLayerYCenter, CapacitorStack.matchingScheme, CapacitorStack.matrixDim, and CapacitorStack.nets.}\par
{
Referenced by RoutMatchedCapacitor.route().}\par
}
{\xe \v drawCuts\:python::capacitorrouted::RoutMatchedCapacitor}
{\xe \v python::capacitorrouted::RoutMatchedCapacitor\:drawCuts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def drawCuts (  {\i self},   {\i layer_hRTrack_hRLayer},   {\i layer_tracksCut},   {\i layer_topPlateCut})}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws all required cuts using physical layers : }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 layer_hRTrack_hRLayer}  to connect bottom plates to vertical routing tracks,\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 layer_tracksCut}  to connect vertical routing tracks to horizontal ones,\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 layer_topPlateCut}  to connect top plates to vertical routing tracks. ALso in {\f2 drawCuts} , nUmber of maximum cuts number on every layer is computed and cuts enclosure is adjusted according to layer's width. \par}
}{
References RoutMatchedCapacitor.__setPlatesLabels__(), VerticalRoutingTracks.capacitorIds, CapacitorStack.capacitorsNumber, RoutMatchedCapacitor.drawCuts_stretchedTopPlate(), RoutMatchedCapacitor.drawCuts_vRoutingTrack_HRLayer(), RoutMatchedCapacitor.drawCuts_vRoutingTrack_hRoutingTrack(), RoutMatchedCapacitor.drawOneCut_vRoutingTrack_HRLayer(), RoutMatchedCapacitor.hRoutingLayerYCenter, CapacitorStack.matchingScheme, CapacitorStack.matrixDim, CapacitorStack.minEnclosure_vRoutingTrackCut, RoutMatchedCapacitor.minSpacing_hRoutingTrackCut, CapacitorStack.minSpacing_vRoutingTrackCut, VerticalRoutingTracks.minWidth_hRoutingTrackCut, CapacitorStack.minWidth_vRoutingTrackCut, CapacitorStack.nets, CapacitorStack.vRoutingTrack_width, and RoutMatchedCapacitor.vRoutingTrackXCenter.}\par
{
Referenced by RoutMatchedCapacitor.route().}\par
}
{\xe \v drawOneCut_vRoutingTrack_HRLayer\:python::capacitorrouted::RoutMatchedCapacitor}
{\xe \v python::capacitorrouted::RoutMatchedCapacitor\:drawOneCut_vRoutingTrack_HRLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def drawOneCut_vRoutingTrack_HRLayer (  {\i self},   {\i net},   {\i cutLayer},   {\i cutXMin},   {\i cutYMin},   {\i cutNumber})}}
\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws one cut, in layer {\f2 cutLayer} , in order to connect a vertical routing track, at position {\f2 cutXMin}  in metal 2, and a horizontal routing track, at position {\f2 cutYMin}  in metal 3. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
References RoutMatchedCapacitor.minSpacing_hRoutingLayer_vRoutingTrack_cut, and VerticalRoutingTracks.minWidth_hRoutingLayer_vRoutingTrack_cut.}\par
{
Referenced by RoutMatchedCapacitor.drawCuts().}\par
}
{\xe \v drawCuts_vRoutingTrack_hRoutingTrack\:python::capacitorrouted::RoutMatchedCapacitor}
{\xe \v python::capacitorrouted::RoutMatchedCapacitor\:drawCuts_vRoutingTrack_hRoutingTrack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def drawCuts_vRoutingTrack_hRoutingTrack (  {\i self},   {\i cutLayer},   {\i cutNumber},   {\i enclosure_cut})}}
\par
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws cuts to connect vertical routing tracks in metal 2 and horizontal routing tracks in metal 3. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
References RoutMatchedCapacitor.__setPlatesIds__(), RoutMatchedCapacitor.capacitor, RoutMatchedCapacitor.dummyRingCapacitor, CapacitorUnit.getBotPlateRLayerWidth(), CapacitorUnit.getBottomPlateLeftCutXMin(), CapacitorUnit.getBottomPlateRightCutXMin(), CapacitorUnit.getTopPlateRLayerWidth(), CapacitorUnit.getTopPlateRLayerXMin(), RoutMatchedCapacitor.hRoutingLayerYCenter, RoutMatchedCapacitor.hRoutingtrackYCenter, CapacitorStack.matchingScheme, CapacitorStack.matrixDim, CapacitorStack.minEnclosure_hRoutingLayer_topPlate_cut, CapacitorStack.minEnclosure_vRoutingTrackCut, RoutMatchedCapacitor.minSpacing_hRoutingLayer_topPlate_cut, RoutMatchedCapacitor.minSpacing_hRoutingTrackCut, CapacitorStack.minSpacing_vRoutingTrackCut, CapacitorStack.minWidth_hRoutingLayer_topPlate_cut, VerticalRoutingTracks.minWidth_hRoutingTrackCut, CapacitorStack.minWidth_vRoutingTrackCut, CapacitorStack.nets, CapacitorStack.vRoutingTrack_width, and RoutMatchedCapacitor.vRoutingTrackXCenter.}\par
{
Referenced by RoutMatchedCapacitor.drawCuts().}\par
}
{\xe \v __stretchTopPlates__\:python::capacitorrouted::RoutMatchedCapacitor}
{\xe \v python::capacitorrouted::RoutMatchedCapacitor\:__stretchTopPlates__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def __stretchTopPlates__ (  {\i self},   {\i capacitor},   {\i rlayer})}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Iteratively performs top plates stretching for the capacitor matrix. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vertical segments are connected to top plate routing layer. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i capacitor} \cell }{Capacitor matrix. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rlayer} \cell }{Layer of the drawn vertical rectangle. \cell }
{\row }
}
}{
References RoutMatchedCapacitor.__stretchTopPlateCompactCap__(), CapacitorStack.matchingScheme, CapacitorStack.matrixDim, and CapacitorStack.nets.}\par
{
Referenced by RoutMatchedCapacitor.route().}\par
}
{\xe \v __stretchTopPlateCompactCap__\:python::capacitorrouted::RoutMatchedCapacitor}
{\xe \v python::capacitorrouted::RoutMatchedCapacitor\:__stretchTopPlateCompactCap__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def __stretchTopPlateCompactCap__ (  {\i self},   {\i net},   {\i capacitor},   {\i routingLayer},   {\i j} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws vertical stretched layers for a given elementary capacitor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
References RoutMatchedCapacitor.__setStretchingDySourceDyTarget__(), and RoutMatchedCapacitor.topPlateStretching.}\par
{
Referenced by RoutMatchedCapacitor.__stretchTopPlates__().}\par
}
{\xe \v __setStretchingDySourceDyTarget__\:python::capacitorrouted::RoutMatchedCapacitor}
{\xe \v python::capacitorrouted::RoutMatchedCapacitor\:__setStretchingDySourceDyTarget__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def __setStretchingDySourceDyTarget__ (  {\i self},   {\i capacitor},   {\i deltay})}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the abcissas of the extremities of the vertical stretching to be applied to capacitor's top plates for a given elementary capacitor in the matrix. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i capacitor} \cell }{.values() Elementary unit capacitor. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i deltay} \cell }{Stretching value. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid A list that contains {\f2 dySource}  and  as top extremity and bottom extermity, respectively. \par
}}{
Referenced by RoutMatchedCapacitor.__stretchTopPlateCompactCap__(), and RoutMatchedCapacitor.computeHRLayerYCenter().}\par
}
{\xe \v __computeConnections__\:python::capacitorrouted::RoutMatchedCapacitor}
{\xe \v python::capacitorrouted::RoutMatchedCapacitor\:__computeConnections__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def __computeConnections__ (  {\i self},   {\i i},   {\i j},   {\i capacitorIdentifier})}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes horizontal routing layers source and target abcissas for top and bottom plates connections to its associated routing track. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i (i,j)} \cell }{row and column indexes, respectively, in the matrix which describe the elementary capacitor position in the matrix. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i capacitorIdentifier} \cell }{equal to '1' if C1 and '2' if C2. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid A nested dicitionary. The overal dictionary is composed of keys equal to {\f2 topPlate}  and  bottomPlate and values equal to sub-dictionaries. The sub-dictionaries, are in their turn composed of two keys standing for the abcissa of the source and the abcissa of the target. \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: Naturally, an exception is raised if an unsupported capacitor identifier is given. \par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid \par
}}{
References RoutMatchedCapacitor.__findHRLDyTrarget__(), RoutMatchedCapacitor.__isCapacitorAdummy__(), RoutMatchedCapacitor.__setPlatesLabels__(), RoutMatchedCapacitor.capacitor, VerticalRoutingTracks.capacitorIds, CapacitorStack.capacitorsNumber, CapacitorStack.dummyElement, CapacitorStack.dummyRing, CapacitorUnit.getTopPlateRLayerXMin(), CapacitorStack.matchingScheme, CapacitorStack.matrixDim, CapacitorStack.nets, CapacitorStack.vRoutingTrack_width, RoutMatchedCapacitor.vRoutingTrackXCenter, RoutMatchedCapacitor.vRTInstance, and RoutMatchedCapacitor.vRTsDistribution.}\par
{
Referenced by RoutMatchedCapacitor.drawHRLayers().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
capacitorrouted.py\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Stack Class Reference\par \pard\plain 
{\tc\tcl2 \v Stack}
{\xe \v Stack}
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draw a {\b Stack} of Transistors. }}\par
{
Inherits object.}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b __init__} (self, device, NERC, NIRC)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [API]}  Constructor }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b setWirings} (self, wiringSpec)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [API]}  Set the {\b Stack} wiring specification. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b computeDimensions} (self)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [internal]}  Compute {\b Stack} dimensions from the technological rules. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b doLayout} (self, bbMode)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [API]}  Draw the complete layout. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draw a {\b Stack} of Transistors. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A {\b Stack} of Transistors is a set of transistor put into a regular band and connected through their sources/drains. All share the exact same W & L. The way they are connecteds defines what functionnality the {\b Stack} implement.\par
The abutment box of the stack is adjusted so that both height and width are even multiples of the track pitches, so the device can be easily placed and handled by the mixed router. The extra space needed for padding is added around the active area. Due to the presence of tracks at the top and bottom of the stack, the active area will be horizontally centered but {\b not}  vertically.\par
The drawing of the stack is controlled through a set of variables (attributes) that allows to create it regardless of the technology. The technology is taken into account in the way those variables are computed and, obviously, their values. The following schematics details the main stack drawing variables along with their computations.\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Stack Layout
\par}
{\tc\tcl2 \v Stack Layout}
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Gate pitch
\par}
{\tc\tcl3 \v Gate pitch}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 self.gatePitch}  : the pitch of transistors gates, inside the stack. It also applies to dummy transistors.\par}
 \par}
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Active Side Width
\par}
{\tc\tcl3 \v Active Side Width}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 self.activeSideWidth}  : the distance between the axis of the last transistor gate (on the left or right) and the edge of the active area ({\i not}  the diffusion area).\par}
 \par}
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
H-Track Distance
\par}
{\tc\tcl3 \v H-Track Distance}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 self.hTrackDistance}  : the minimal distance between either the top or bottom edge of the active area and the {\i axis}  of the first track.\par}
 \par}
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
BoundingBox & Overall Variables
\par}
{\tc\tcl3 \v BoundingBox & Overall Variables}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 self.xpitches}  : the number of vertical track pitches needed to fully enclose the active area.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 self.ypitches}  : the number of horizontal track pitches needed to fully enclose the active area.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 self.activeOffsetX}  & {\f2 self.activeOffsetY}  : the offsets of the active area from the bottom left corner of the abutment box.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 self.diffusionWidth}  & {\f2 self.diffusionHeight}  are the minimun dimensions required to fit the active area.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 self.topTracksNb()}  : the number of tracks at the top of the stack.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 self.botTracksNb()}  : the number of tracks at the bottom of the stack.\par}
 \par}
\par}
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Wiring Specifications
\par}
{\tc\tcl2 \v Wiring Specifications}
{\b Stack} routing is done through vertical {\f2 metal1}  wires coming from the gates and diffusions areas and {\f2 metal2}  horizontal wires that can be either above or below the active area. {\f2 metal2}  wires (or track) goes through the whole stack and are assigned to one net only. A net will have at least one track above or below and may have both.\par
The connections to the diffusions areas and gates of the various fingers are specified through a list. The stack is made of a regular alternation of diffusions and gates. The list tells, for each one starting from the left, to which net and track they are connected. For a stack of $NFs$ transistor fingers, the must wiring specification must contains $ 3 + (NFs-1) \times 2$ elements. The list is given through one {\i string}  with each elements separated by one or more whitespace. The syntax for {\i one}  element is detailed {\b Atomic Wiring Specification}.\par
{\b Track numbering scheme} \par
Tracks above (top) the active area and below (bottom) each have their own numbering. In both case, the count start {\i from}  the active area. This, the top tracks will be numbered by increasing Y and the bottom tracks by {\i decreasing}  Y.\par
{\b Track/Net assignement} \par
The track/net assignement is deduced from the atomic wiring specifications. It also allows to compute the total number of tracks needed above and below the active area.\par
 \par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atomic Wiring Specification
\par}
{\tc\tcl3 \v Atomic Wiring Specification}
An atomic wiring specification has the same syntax for either diffusions or gates. It {\i must}  not comprise any whitespaces. it is made of the following parts:{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The net name to connect to.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Whether the track is above the active area ({\f2 "t"} ) or below ({\f2 "b"} ). The special case ({\f2 "z"} ) means that this element must be left unconnected (is such case possible?).\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The number of the track.\par}
 \par}
\par}
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Stack Implementation Details
\par}
{\tc\tcl2 \v Stack Implementation Details}
The {\f2 __setattr__()}  and {\f2 __getattr__}  functions have been redefined so that the technological values (rules) can be accessed has normal attributes of the {\b Stack} class, in addition to the regular ones. \par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v __init__\:python::stack::Stack}
{\xe \v python::stack::Stack\:__init__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def __init__ (  {\i self},   {\i device},   {\i NERC},   {\i NIRC})}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [API]}  Constructor }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
param rules The physical rule set. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i device} \cell }{The {\b Hurricane} AMS device into which the layout will be drawn. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i NERC} \cell }{Number of contact rows in external (first & last) diffusion connectors. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i NIRC} \cell }{Number of contact rows in middle diffusion connectors. param w The {\b width}  of every transistor of the stack (aka {\i fingers} ). param L The {\b length}  of every transistor. param NFs The total number of fingers (dummies includeds). param NDs The number of dummies to put on each side of the stack. \cell }
{\row }
}
}{
References Stack.bImplantLayer, Stack.botTracks, Stack.botWTracks, Stack.bulkNet, Stack.bulks, Stack.device, Stack.dimensioned, Bulk.flags, Stack.flags, Stack.isNmos(), Stack.L, Stack.metaTnb(), Stack.metaTransistors, Stack.NDs, Stack.NERC, Stack.NFs, Stack.NIRC, Stack.tImplantLayer, Stack.topTracks, Stack.topWTracks, Stack.w, Stack.wellLayer, and Stack.wirings.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v setWirings\:python::stack::Stack}
{\xe \v python::stack::Stack\:setWirings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def setWirings (  {\i self},   {\i wiringSpec})}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [API]}  Set the {\b Stack} wiring specification. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i wiringSpec} \cell }{A string defining the connections for the gates and diffusion areas.\cell }
{\row }
}
For a comprehensive explanation of the wiring specification, refers to {\b Wiring Specifications} . \par
}{
References Stack.botTracks, Stack.botTracksNb(), Stack.botWTracks, Stack.bulkNet, Stack.computeDimensions(), Stack.device, Stack.dimensioned, Stack.eDiffMetal1Width, Bulk.flags, Stack.flags, Stack.gatePitch, Stack.getBotTrackY(), Stack.getHorizontalWidth(), Stack.horPitch, Stack.L, Stack.metal1ToGate, Stack.metaTransistors, Stack.sideActiveWidth, Stack.topTracks, Stack.topTracksNb(), Stack.topWTracks, Stack.wirings, and Stack.ypitches.}\par
}
{\xe \v computeDimensions\:python::stack::Stack}
{\xe \v python::stack::Stack\:computeDimensions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def computeDimensions (  {\i self})}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [internal]}  Compute {\b Stack} dimensions from the technological rules. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Internal function.}  Perform the computation of:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 self.metal1Pitch}  \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 self.minWidth_metal1}  \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 self.metal2Pitch}  \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 self.minWidth_metal2}  \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 self.gatePitch}  \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 self.sideActiveWidth}  \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 self.hTrackDistance}  \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 self.xpitches}  \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 self.ypitches}  \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 self.activeOffsetX}  \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 self.activeOffsetY}  \par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 self.boundingBox}  \par}
}{
References Stack.activeBox, Stack.activeOffsetX, Stack.activeOffsetY, Stack.bbHeight, Stack.bbWidth, Stack.botWTracks, Stack.boundingBox, Stack.bulks, Stack.bulkWidth, Stack.computeLayoutParasitics(), Stack.computeStressEffect(), Stack.contactDiffPitch, Stack.contactDiffSide, Stack.DGG, Stack.DGI, Stack.dimensioned, Stack.DMCG, Stack.DMCGT, Stack.DMCI, Stack.eDiffMetal1Width, Bulk.flags, Stack.flags, Stack.gatePitch, Stack.gateVia1Pitch, Stack.getBotTrackY(), Stack.getHorizontalWidth(), Stack.getLastTopTrackY(), Stack.horPitch, Stack.hTrackDistance, Stack.iDiffMetal1Width, Stack.isVH, Stack.L, Stack.metal1ToGate, Stack.metal2Pitch, Stack.metal2TechnoPitch, Stack.metal3Pitch, Stack.metaTransistors, Stack.NERC, Stack.NFs, Stack.NIRC, Stack.sideActiveWidth, Stack.tracksNbPitch(), Stack.vBulkDistance, Stack.verPitch, Stack.w, Stack.wire1Width, Stack.wire2Width, Stack.wire3Width, Stack.wirings, Stack.xpitches, and Stack.ypitches.}\par
{
Referenced by CapacitorUnit.create(), Stack.doLayout(), RoutMatchedCapacitor.route(), and Stack.setWirings().}\par
}
{\xe \v doLayout\:python::stack::Stack}
{\xe \v python::stack::Stack\:doLayout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def doLayout (  {\i self},   {\i bbMode})}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b [API]}  Draw the complete layout. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draw the commplete layout of the {\b Stack}. \par
}{
References Stack.activeOffsetX, Stack.activeOffsetY, Stack.bbWidth, Stack.botTracks, Stack.botWTracks, Stack.boundingBox, Stack.bulkNet, Stack.bulks, Stack.bulkWidth, Stack.computeDimensions(), Stack.contactDiffPitch, Stack.device, Stack.DGG, Stack.DGI, Stack.DMCG, Stack.DMCGT, Stack.DMCI, Stack.drawActive(), Stack.drawGate(), Stack.drawSourceDrain(), Stack.drawWell(), Stack.eDiffMetal1Width, Bulk.flags, Stack.flags, Stack.gatePitch, Stack.gateVia1Pitch, Stack.getBotTrackY(), Stack.getHorizontalAxis(), Stack.getHorizontalWidth(), Stack.getTopTrackY(), Stack.getWiringWidth(), Stack.horPitch, Stack.iDiffMetal1Width, Stack.isBotTrack(), Stack.isVH, Stack.L, Stack.metal1ToGate, Stack.NERC, Stack.NFs, Stack.NIRC, Stack.sideActiveWidth, Stack.tImplantLayer, Stack.topTracks, Stack.topWTracks, Stack.w, Stack.wellLayer, Stack.wire1Width, Stack.wire2Width, Stack.wire3Width, and Stack.wirings.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
stack.py\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
VerticalRoutingTracks Class Reference\par \pard\plain 
{\tc\tcl2 \v VerticalRoutingTracks}
{\xe \v VerticalRoutingTracks}
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Route two matched capacitors, C1 and C2, drawn in a capacitor matrix. }}\par
Inheritance diagram for VerticalRoutingTracks:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classpython_1_1capacitorvrtracks_1_1VerticalRoutingTracks__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b __setStretching__} (self)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets vertical stretching value considering spacing between elementary capacitors in the matrix. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b setRules} (self)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines technology rules used to draw the layout. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
def {\b drawVRoutingTracks} (self, vRoutingTracksLayer)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Iteratively draws vertical routing tracks given the physical layer {\f2 vRoutingTracksLayer} . }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Route two matched capacitors, C1 and C2, drawn in a capacitor matrix. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connections are put in place with reference to a given matching scheme. Elementary capacitor units are connected to horizontal and vertical routing tracks that represent top plates and bottom plates nets of C1 and C2. Supported types of capacitors are Poly-Poly and Metal-Metal. Technologycal rules are provided by 350 nm AMS CMOS technology with three-four metal layers. Metal layers that are used for routeing are placed similarly to horziontal-vertical (HV) symbolic Alliance CAD tool router, where horizontal metal channels are drawn in metal 2 and the vertical ones are in metal 3. Given a matrix of dimensions $ R*C $, the total number of vertical tracks is $ 2C+2 $ equivalent to $ C+1 $ couples, ensuring that every elementary capacitor is positioned between four vertical tracks, two from each side. In fact, every adjacent couple of these tracks represent top plates and bottom plates of C1 or C2 as shown in Figure 1.\par
An elementary capacitor unit can be a part of C1 or C2 according to the matching scheme. However, to respect common-centroid layout specifications, for C1 and C2 to be equal, the matrix number of colums and number of rows must be both even. Addionnally, the number of elementary capacitors dedicated to C1 must be equal to those dedicated to C2. These two conditions are tested in one of the class methods. An exception is raised if at least one of the two is not respected. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v __setStretching__\:python::capacitorvrtracks::VerticalRoutingTracks}
{\xe \v python::capacitorvrtracks::VerticalRoutingTracks\:__setStretching__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def __setStretching__ (  {\i self})}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets vertical stretching value considering spacing between elementary capacitors in the matrix. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid stratching value. \par
}}{
References CapacitorStack.abutmentBox_spacing.}\par
{
Referenced by RoutMatchedCapacitor.computeHRLayerYCenter(), and VerticalRoutingTracks.drawVRoutingTracks().}\par
}
{\xe \v setRules\:python::capacitorvrtracks::VerticalRoutingTracks}
{\xe \v python::capacitorvrtracks::VerticalRoutingTracks\:setRules}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def setRules (  {\i self})}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines technology rules used to draw the layout. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Some of the rules, namely those describing routeing layers and tracks are applicable for both MIM and PIP capacitors. However, cuts rules are different. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remark: All {\f2 CapacitorStack}  class rules are also reloaded in this class. An exception is raised if the entered capacitor type is unsupported. \par
}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid a dictionary with rules labels as keys and rules content as values. \par
}}{
References VerticalRoutingTracks.capacitorInstance, CapacitorStack.capacitorsNumber, VerticalRoutingTracks.computeVRTDimensions(), VerticalRoutingTracks.drawVRoutingTracks(), VerticalRoutingTracks.minEnclosure_hRoutingLayer_vRoutingTrack_cut, VerticalRoutingTracks.minEnclosure_hRoutingTrackCut, VerticalRoutingTracks.minimizeVRTs(), VerticalRoutingTracks.minSpacing_hRoutingTrack, RoutMatchedCapacitor.minSpacing_hRoutingTrack, VerticalRoutingTracks.minWidth_hRoutingLayer, VerticalRoutingTracks.minWidth_hRoutingLayer_vRoutingTrack_cut, VerticalRoutingTracks.minWidth_hRoutingTrack, VerticalRoutingTracks.minWidth_hRoutingTrackCut, and CapacitorUnit.setRules().}\par
}
{\xe \v drawVRoutingTracks\:python::capacitorvrtracks::VerticalRoutingTracks}
{\xe \v python::capacitorvrtracks::VerticalRoutingTracks\:drawVRoutingTracks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
def drawVRoutingTracks (  {\i self},   {\i vRoutingTracksLayer})}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Iteratively draws vertical routing tracks given the physical layer {\f2 vRoutingTracksLayer} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Every elementary capacitor is consequently positioned between four routing tracks, two from each side. Each couple of adjacent routeing tracks represent top plate and bottom plate nets of Ci, where i is in [1,2]. As given in Figure 2, capacitor $ C_{ij} $ with an even j value situated in even columns have and inversely for odd columns numbers. \par
}{
References VerticalRoutingTracks.__computeVRTsNumber__(), VerticalRoutingTracks.__findCapIdsToEliminate__(), VerticalRoutingTracks.__findCapIdsToEliminatePerColumn__(), VerticalRoutingTracks.__findUsedCapIdsPerColumn__(), VerticalRoutingTracks.__findVRTsToEliminate__(), VerticalRoutingTracks.__setNetsDistribution__(), VerticalRoutingTracks.__setPlatesDistribution__(), VerticalRoutingTracks.__setStretching__(), VerticalRoutingTracks.__setVRTsDistribution__(), CapacitorUnit.abutmentBox, CapacitorStack.abutmentBox_spacing, VerticalRoutingTracks.capacitorIds, VerticalRoutingTracks.capacitorInstance, CapacitorStack.capacitorsNumber, VerticalRoutingTracks.computeXCenters(), CapacitorStack.dummyElement, CapacitorStack.dummyRing, VerticalRoutingTracks.getVTrackYMax(), VerticalRoutingTracks.getVTrackYMin(), CapacitorUnit.hpitch, RoutMatchedCapacitor.hRoutingTrack_width, VerticalRoutingTracks.hRoutingTrack_width, CapacitorStack.matchingScheme, CapacitorStack.matrixDim, RoutMatchedCapacitor.maximumPosition, VerticalRoutingTracks.maximumPosition, CapacitorUnit.metal2Width, VerticalRoutingTracks.minEnclosure_hRoutingTrackCut, VerticalRoutingTracks.minimizeVRT, RoutMatchedCapacitor.minimumPosition, VerticalRoutingTracks.minimumPosition, VerticalRoutingTracks.minWidth_hRoutingTrack, VerticalRoutingTracks.minWidth_hRoutingTrackCut, CapacitorStack.nets, VerticalRoutingTracks.platesDistribution, CapacitorStack.vRoutingTrack_width, VerticalRoutingTracks.vRoutingTrackDict, RoutMatchedCapacitor.vRoutingTrackDict, VerticalRoutingTracks.vRoutingTrackXCenter, RoutMatchedCapacitor.vRoutingTrackXCenter, VerticalRoutingTracks.vRTsDistribution, RoutMatchedCapacitor.vRTsDistribution, and VerticalRoutingTracks.vRTsToEliminate.}\par
{
Referenced by VerticalRoutingTracks.setRules().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
capacitorvrtracks.py\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}